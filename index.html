<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêö</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manila Clam Pattern Generator</title>
    <style>
        :root {
            /* KU Brand Colors */
            --ku-black: #1D1D1B;
            --ku-white: #FFFFFF;
            --ku-yellow: #FFF200;
            --ku-navy: #002b49;
            --ku-blue: #009cde;
            --ku-green: #78be20;
            --ku-orange: #e35205;
            --ku-gold: #ffb500;
            --ku-light-blue: #77c5d5;
            --ku-tan: #857550;
            --ku-purple: #9370DB;
            
            /* Pattern Type Colors - used in dropdown */
            --pattern-cellular: var(--ku-orange);
            --pattern-wave: var(--ku-blue);
            --pattern-growth: var(--ku-green);
            --pattern-voronoi: var(--ku-purple);
            --pattern-radial: var(--ku-gold);
        }
        
        * {
            box-sizing: border-box;
            font-family: Arial, "Helvetica Neue", sans-serif;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: var(--ku-white);
            color: var(--ku-black);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: var(--ku-navy);
        }
        
        header {
            margin-bottom: 30px;
            text-align: center;
            position: relative;
        }
        
        .banner {
            background-color: var(--ku-navy);
            color: var(--ku-white);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .banner h1 {
            margin: 0;
            color: var(--ku-white);
        }
        
        .banner p {
            margin: 10px 0 0;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        
        .controls {
            flex: 1;
            min-width: 300px;
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .canvas-container {
            flex: 2;
            min-width: 300px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #previewCanvas {
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 1;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .hidden-canvas {
            display: none;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin-bottom: 10px;
            border-bottom: 2px solid var(--ku-blue);
            padding-bottom: 5px;
        }
        
        label {
            display: block;
            margin: 12px 0 6px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        .value-display {
            display: inline-block;
            width: 50px;
            text-align: right;
            margin-left: 10px;
        }
        
        /* Custom select styling with pattern type colors */
        .pattern-select-container {
            position: relative;
            width: 100%;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            padding-right: 30px;
        }
        
        .pattern-select-container::after {
            content: '‚ñº';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 12px;
        }
        
        /* Pattern type options with color indicators */
        select#patternType option[value="cellular"] {
            background-color: rgba(227, 82, 5, 0.2);
        }
        
        select#patternType option[value="wave"] {
            background-color: rgba(0, 156, 222, 0.2);
        }
        
        select#patternType option[value="growth"] {
            background-color: rgba(120, 190, 32, 0.2);
        }
        
        select#patternType option[value="voronoi"] {
            background-color: rgba(147, 112, 219, 0.2);
        }
        
        select#patternType option[value="radial"] {
            background-color: rgba(255, 181, 0, 0.2);
        }
        
        /* Canvas size inputs for garment panels */
        .canvas-size-inputs {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .canvas-size-inputs input[type="number"] {
            width: 90px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .canvas-size-inputs select {
            width: 90px;
        }
        
        input[type="color"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
        }
        
        button {
            background-color: var(--ku-blue);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
            width: 100%;
            margin-top: 5px;
        }
        
        button:hover {
            background-color: var(--ku-navy);
        }
        
        button.secondary {
            background-color: var(--ku-gold);
        }
        
        button.secondary:hover {
            background-color: var(--ku-orange);
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }
        
        .tooltip-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 18px;
            height: 18px;
            background-color: var(--ku-light-blue);
            color: white;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
        }
        
        .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: var(--ku-navy);
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: normal;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Focus styles for better keyboard navigation */
        button:focus, input:focus, select:focus {
            outline: 3px solid var(--ku-yellow);
            outline-offset: 2px;
        }
        
        /* Additional CSS for new components */
        .color-pickers {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .color-picker {
            flex: 1;
        }

        .color-picker label {
            font-size: 14px;
            margin-bottom: 5px;
        }

        /* Animation controls */
        .animation-controls {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 600px;
            margin-top: 15px;
            background-color: #f5f5f5;
            border-radius: 8px;
            padding: 10px;
        }

        .animation-controls button {
            width: auto;
            margin-top: 0;
            padding: 8px 12px;
            font-size: 14px;
        }

        .animation-controls .play-pause {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--ku-blue);
            margin-right: 10px;
            padding: 0;
        }

        .animation-controls .play-pause:hover {
            background-color: var(--ku-navy);
        }

        .animation-controls .play-pause svg {
            width: 20px;
            height: 20px;
            margin: 0;
        }

        .animation-controls .speed-controls {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .animation-controls .speed-controls button {
            margin: 0 2px;
            background-color: #ddd;
            color: #333;
        }

        .animation-controls .speed-controls button:hover,
        .animation-controls .speed-controls button.active {
            background-color: var(--ku-blue);
            color: white;
        }

        .animation-controls .timeline {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin: 0 10px;
        }

        .animation-controls .timeline-slider {
            width: 100%;
            margin: 0;
        }

        .animation-controls .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 2px;
        }

        /* Age bands visualization */
        .age-bands {
            width: 100%;
            max-width: 600px;
            height: 20px;
            margin-top: 5px;
            display: flex;
            overflow: hidden;
            border-radius: 10px;
        }

        .age-band {
            height: 100%;
            flex-grow: 1;
            transition: background-color 0.3s;
        }

        /* Pattern blend visualization */
        .pattern-blend {
            width: 100%;
            max-width: 600px;
            margin-top: 15px;
            background-color: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
        }

        .pattern-blend h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .blend-bars {
            display: flex;
            width: 100%;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .blend-bar {
            height: 100%;
            transition: width 0.5s;
        }

        .blend-bar.cellular {
            background-color: var(--ku-orange);
        }

        .blend-bar.wave {
            background-color: var(--ku-blue);
        }

        .blend-bar.growth {
            background-color: var(--ku-green);
        }

        .blend-bar.voronoi {
            background-color: var(--ku-purple);
        }

        .blend-bar.radial {
            background-color: var(--ku-gold);
        }

        .blend-labels {
            display: flex;
            flex-wrap: wrap;
            margin-top: 5px;
            font-size: 12px;
        }

        .blend-label {
            text-align: left;
            margin-right: 10px;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="banner">
                <h1>Manila Clam Pattern Generator</h1>
                <p>Create generative designs inspired by Venerupis Philippinarum shell patterns</p>
            </div>
        </header>
        
        <main id="main">
            <div class="main-content">
                <div class="controls">
                    <div class="control-group">
                        <h3>Pattern Settings</h3>
                        
                        <label for="patternType">Initial Pattern Type</label>
                        <div class="pattern-select-container">
                            <select id="patternType">
                                <option value="cellular">Cellular Automaton</option>
                                <option value="wave">Wave Interference</option>
                                <option value="growth">Growth Rings</option>
                                <option value="voronoi">Voronoi Texture</option>
                                <option value="radial">Radial Symmetry</option>
                            </select>
                        </div>
                        <div class="tooltip">
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">
                                <strong>Cellular:</strong> Creates organic, cellular patterns<br>
                                <strong>Wave:</strong> Creates wavy, flowing patterns<br>
                                <strong>Growth:</strong> Creates concentric ring patterns<br>
                                <strong>Voronoi:</strong> Creates cell-like mesh patterns<br>
                                <strong>Radial:</strong> Creates radial lines and rings from top
                            </span>
                        </div>
                        
                        <label for="patternBlending">Pattern Evolution
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Controls how the pattern algorithm changes as the clam ages. Higher values create more dynamic evolution.</span>
                            </span>
                            <span class="value-display" id="patternBlendingValue">50</span>
                        </label>
                        <input type="range" id="patternBlending" min="0" max="100" value="50" aria-labelledby="patternBlendingValue">
                        
                        <label for="complexity">Pattern Complexity
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Higher values create more intricate patterns with finer details.</span>
                            </span>
                            <span class="value-display" id="complexityValue">50</span>
                        </label>
                        <input type="range" id="complexity" min="10" max="100" value="50" aria-labelledby="complexityValue">
                        
                        <label for="symmetry">Bilateral Symmetry
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Controls how symmetrical the pattern is across the central axis.</span>
                            </span>
                            <span class="value-display" id="symmetryValue">50</span>
                        </label>
                        <input type="range" id="symmetry" min="0" max="100" value="50" aria-labelledby="symmetryValue">
                    </div>
                    
                    <div class="control-group">
                        <h3>Output Size</h3>
                        <label for="canvasWidth">Width
                            <span class="value-display" id="canvasWidthValue">30</span>
                        </label>
                        <div class="canvas-size-inputs">
                            <input type="number" id="canvasWidth" min="1" max="500" value="30" aria-labelledby="canvasWidthValue">
                            <select id="canvasWidthUnit">
                                <option value="cm">cm</option>
                                <option value="in">inches</option>
                            </select>
                        </div>
                        
                        <label for="canvasHeight">Height
                            <span class="value-display" id="canvasHeightValue">30</span>
                        </label>
                        <div class="canvas-size-inputs">
                            <input type="number" id="canvasHeight" min="1" max="500" value="30" aria-labelledby="canvasHeightValue">
                            <select id="canvasHeightUnit">
                                <option value="cm">cm</option>
                                <option value="in">inches</option>
                            </select>
                        </div>
                        
                        <label for="canvasResolution">Resolution (DPI)
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Higher DPI creates larger, more detailed files suitable for printing. Standard print quality is 300 DPI.</span>
                            </span>
                            <span class="value-display" id="canvasResolutionValue">150</span>
                        </label>
                        <input type="range" id="canvasResolution" min="72" max="300" value="150" step="1" aria-labelledby="canvasResolutionValue">
                    </div>
                    <div class="control-group">
                        <h3>Climate Scenario</h3>
                        
                        <label for="climateScenario">UK Climate Scenario</label>
                        <select id="climateScenario">
                            <option value="pre-industrial">Pre-Industrial (Stable)</option>
                            <option value="current" selected>Current UK Waters</option>
                            <option value="near-future">Near-Future UK (2050)</option>
                            <option value="worst-case">Worst-Case UK (2100)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <h3>Environmental Factors</h3>
                        
                        <label for="temperature">Starting Temperature (¬∞C)
                            <span class="value-display" id="temperatureValue">14</span>
                        </label>
                        <input type="range" id="temperature" min="5" max="28" value="14" aria-labelledby="temperatureValue">
                        
                        <label for="salinity">Starting Salinity (ppt)
                            <span class="value-display" id="salinityValue">32</span>
                        </label>
                        <input type="range" id="salinity" min="25" max="38" value="32" aria-labelledby="salinityValue">
                        
                        <label for="sediment">Sediment Concentration (mg/L)
                            <span class="tooltip">
                                <span class="tooltip-icon">?</span>
                                <span class="tooltip-text">Sediment levels affect shell texture and surface pattern. Higher values create more textured, uneven patterns as found in muddy or silty habitats.</span>
                            </span>
                            <span class="value-display" id="sedimentValue">20</span>
                        </label>
                        <input type="range" id="sediment" min="0" max="100" value="20" aria-labelledby="sedimentValue">
                        
                        <label for="acidification">Starting Acidification (pH)
                            <span class="value-display" id="acidificationValue">0</span>
                        </label>
                        <input type="range" id="acidification" min="0" max="100" value="0" aria-labelledby="acidificationValue">
                        
                        <label for="microplastics">Microplastic Concentration
                            <span class="value-display" id="microplasticsValue">15</span>
                        </label>
                        <input type="range" id="microplastics" min="0" max="100" value="15" aria-labelledby="microplasticsValue">
                        
                        <label for="seasonalVariation">Seasonal Variation
                            <span class="value-display" id="seasonalVariationValue">40</span>
                        </label>
                        <input type="range" id="seasonalVariation" min="0" max="100" value="40" aria-labelledby="seasonalVariationValue">
                        
                        <label for="environmentalEvents">Environmental Events
                            <span class="value-display" id="environmentalEventsValue">3</span>
                        </label>
                        <input type="range" id="environmentalEvents" min="0" max="10" value="3" aria-labelledby="environmentalEventsValue">
                    </div>
                    
                    <div class="control-group">
                        <h3>Growth Settings</h3>
                        
                        <label for="growthYears">Growth Period (Years)
                            <span class="value-display" id="growthYearsValue">3</span>
                        </label>
                        <input type="range" id="growthYears" min="1" max="10" value="3" aria-labelledby="growthYearsValue">
                    </div>
                    
                    <div class="control-group">
                        <h3>Colour Settings</h3>
                        
                        <div class="color-pickers">
                            <div class="color-picker">
                                <label for="baseColor">Base</label>
                                <input type="color" id="baseColor" value="#e8d6b3">
                            </div>
                            <div class="color-picker">
                                <label for="accentColor">Accent</label>
                                <input type="color" id="accentColor" value="#6a4c3b">
                            </div>
                            <div class="color-picker">
                                <label for="microplasticColor">Microplastic</label>
                                <input type="color" id="microplasticColor" value="#9370DB">
                            </div>
                            <div class="color-picker">
                                <label for="sedimentColor">Sediment</label>
                                <input type="color" id="sedimentColor" value="#a08563">
                            </div>
                        </div>
                        
                        <label for="colorVariation">Colour Variation
                            <span class="value-display" id="colorVariationValue">30</span>
                        </label>
                        <input type="range" id="colorVariation" min="0" max="100" value="30" aria-labelledby="colorVariationValue">
                    </div>
                    
                    <div class="action-buttons">
                        <button id="generateButton" type="button">Start New Growth Simulation</button>
                        <button id="downloadButton" type="button" class="secondary">Download High Resolution Pattern</button>
                        <button id="resetButton" type="button">Reset Parameters</button>
                    </div>
                </div>
                
                <div class="canvas-container">
                    <canvas id="previewCanvas" width="600" height="600" aria-label="Manila clam shell pattern preview"></canvas>
                    
                    <div class="animation-controls">
                        <button id="playPauseButton" class="play-pause" aria-label="Play animation">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                <polygon points="5 3 19 12 5 21 5 3" fill="currentColor"></polygon>
                            </svg>
                        </button>
                        
                        <div class="timeline">
                            <input type="range" id="timelineSlider" class="timeline-slider" min="0" max="100" value="0" aria-label="Timeline slider">
                            <div class="time-display">
                                <span id="currentTimeDisplay">0y 0m</span>
                                <span id="totalTimeDisplay">3y 0m</span>
                            </div>
                        </div>
                        
                        <div class="speed-controls">
                            <button id="speedSlow" class="speed-btn" data-speed="0.5" aria-label="Half speed">0.5√ó</button>
                            <button id="speedNormal" class="speed-btn active" data-speed="1" aria-label="Normal speed">1√ó</button>
                            <button id="speedFast" class="speed-btn" data-speed="2" aria-label="Double speed">2√ó</button>
                        </div>
                    </div>
                    
                    <div id="ageBands" class="age-bands" aria-label="Age bands visualization"></div>
                    
                    <div class="pattern-blend">
                        <h3>Pattern Algorithm Blend</h3>
                        <div class="blend-bars" id="blendBars">
                            <div class="blend-bar cellular" style="width: 100%;"></div>
                            <div class="blend-bar wave" style="width: 0%;"></div>
                            <div class="blend-bar growth" style="width: 0%;"></div>
                            <div class="blend-bar voronoi" style="width: 0%;"></div>
                            <div class="blend-bar radial" style="width: 0%;"></div>
                        </div>
                        <div class="blend-labels">
                            <div class="blend-label" id="cellularBlendLabel">Cellular: 100%</div>
                            <div class="blend-label" id="waveBlendLabel">Wave: 0%</div>
                            <div class="blend-label" id="growthBlendLabel">Growth: 0%</div>
                            <div class="blend-label" id="voronoiBlendLabel">Voronoi: 0%</div>
                            <div class="blend-label" id="radialBlendLabel">Radial: 0%</div>
                        </div>
                    </div>
                   <!-- Environment panels -->
                    <div class="environment-history">
                        <h3>Environmental History</h3>
                        
                        <div class="graph-container" id="environmentGraph">
                            <div class="graph-y-axis">
                                <span>High</span>
                                <span>Med</span>
                                <span>Low</span>
                            </div>
                            
                            <div class="graph-line" style="top: 0%;"></div>
                            <div class="graph-line" style="top: 50%;"></div>
                            <div class="graph-line" style="top: 100%;"></div>
                            
                            <div class="climate-trend" id="climateTrend"></div>
                            <div class="data-line" id="temperatureLine"></div>
                            <div class="data-line" id="salinityLine"></div>
                            <div class="data-line" id="seasonalLine"></div>
                            <div class="data-line" id="microplasticLine"></div>
                            <div class="data-line" id="acidificationLine"></div>
                            <div class="data-line" id="sedimentLine"></div>
                        </div>
                        
                        <div class="graph-legend">
                            <div class="legend-item">
                                <div class="legend-color temperature"></div>
                                <span>Temperature</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color salinity"></div>
                                <span>Salinity</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color seasonal"></div>
                                <span>Seasonal</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color microplastic"></div>
                                <span>Microplastics</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color acidification"></div>
                                <span>Acidification</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color sediment"></div>
                                <span>Sediment</span>
                            </div>
                        </div>
                    </div>

                    <div class="growth-info" id="growthInfo">
                        <h3>Growth Information</h3>
                        <p>Ready to start growth simulation. Press the play button to begin.</p>
                        <!-- Growth events will be added here dynamically -->
                    </div>

                    <div class="tabs">
                        <div class="tab-buttons" role="tablist">
                            <button class="tab-button active" data-tab="about" aria-selected="true" id="about-tab" aria-controls="aboutTab" role="tab">About Manila Clams</button>
                            <button class="tab-button" data-tab="uk" aria-selected="false" id="uk-tab" aria-controls="ukTab" role="tab">UK Habitats</button>
                            <button class="tab-button" data-tab="climate" aria-selected="false" id="climate-tab" aria-controls="climateTab" role="tab">Climate Effects</button>
                            <button class="tab-button" data-tab="patterns" aria-selected="false" id="patterns-tab" aria-controls="patternsTab" role="tab">Shell Patterns</button>
                            <button class="tab-button" data-tab="fashion" aria-selected="false" id="fashion-tab" aria-controls="fashionTab" role="tab">Fashion Application</button>
                        </div>
                        
                        <div class="tab-content">
                            <div class="tab-panel about active" id="aboutTab" role="tabpanel" aria-labelledby="about-tab">
                                <h3>About Manila Clam Patterns</h3>
                                <p>The Manila clam (Venerupis philippinarum, also known as Ruditapes philippinarum) creates its shell pattern by depositing calcium carbonate and proteins in layers as it grows. Each new row in the pattern builds upon the previous one, with environmental factors like water temperature, salinity, sediment, and food availability influencing the appearance.</p>
                                <p>This simulator mimics that process, building the pattern line by line over time. You can watch the pattern develop, see how environmental changes affect growth, and observe how the shell responds to conditions just like a real clam would in nature.</p>
                            </div>
                            
                            <div class="tab-panel uk" id="ukTab" role="tabpanel" aria-labelledby="uk-tab">
                                <h3>Manila Clams in UK Waters</h3>
                                <p>In the UK, Manila clams were deliberately introduced for aquaculture in the 1980s. They have established wild populations primarily in southern England, particularly in:</p>
                                <ul>
                                    <li><strong>Poole Harbour, Dorset</strong> - Extensive wild populations</li>
                                    <li><strong>Southampton Water</strong> - Established beds</li>
                                    <li><strong>The Solent & Portsmouth Harbour</strong> - Growing populations</li>
                                    <li><strong>Essex & Thames Estuary</strong> - Multiple colonies</li>
                                    <li><strong>Coastal Wales</strong> - Smaller emerging populations</li>
                                </ul>
                                <p>They prefer sheltered estuaries and harbours with sandy/muddy substrates. UK specimens typically grow to 4-6cm in diameter and form shells with distinctive patterning varying from sandy yellow to deep brown with dark zigzag markings.</p>
                                <p>As non-native species, their spread is closely monitored, though they are considered naturalized and commercially important for UK shellfish industry.</p>
                            </div>
                            
                            <div class="tab-panel climate" id="climateTab" role="tabpanel" aria-labelledby="climate-tab">
                                <h3>Climate Change Effects in UK Waters</h3>
                                <p>Research shows Manila clams in UK waters are affected by climate change:</p>
                                <ul>
                                    <li><strong>Ocean Acidification:</strong> UK coastal waters are experiencing decreasing pH, reducing calcium carbonate availability and resulting in thinner, more irregular shell patterns.</li>
                                    <li><strong>Rising Water Temperatures:</strong> Average UK sea surface temperatures have risen by about 0.8¬∞C since 1980, affecting clam metabolism and growth patterns.</li>
                                    <li><strong>Changing Rainfall Patterns:</strong> More intense rainfall events in the UK alter estuarine salinity levels, creating stress bands in shell growth.</li>
                                    <li><strong>Increased Storm Frequency:</strong> More severe UK winter storms disrupt feeding and growth, visible as interruptions in shell patterning.</li>
                                    <li><strong>Sediment Dynamics:</strong> Changing river flows and coastal erosion alter sediment distribution in estuaries, affecting shell surface textures and patterns.</li>
                                </ul>
                                <p>The simulation includes four climate scenarios to demonstrate these effects on shell growth and pattern formation over time in UK conditions.</p>
                            </div>
                            
                            <div class="tab-panel patterns" id="patternsTab" role="tabpanel" aria-labelledby="patterns-tab">
                                <h3>Shell Pattern Formation</h3>
                                <p>Manila clam shells display several distinctive pattern characteristics:</p>
                                <ul>
                                    <li><strong>Radial Symmetry</strong> - Patterns radiate from the top edge with bilateral symmetry</li>
                                    <li><strong>Concentric Growth Rings</strong> - Arched bands following the shell's growth over time</li>
                                    <li><strong>Reticulated Texture</strong> - Fine broken lines or mesh-like patterns</li>
                                    <li><strong>Pigment Clusters</strong> - Random organic-looking spots or speckles</li>
                                    <li><strong>Sediment Incorporation</strong> - Texture variations based on substrate type</li>
                                </ul>
                                <p>As clams age, their shell formation processes adapt:</p>
                                <ul>
                                    <li>Young clams show simpler patterns focused on rapid growth</li>
                                    <li>Mature clams develop more complex patterns with finer details</li>
                                    <li>The mantle cells responsible for shell secretion change behavior based on environmental stress</li>
                                </ul>
                                <p>This simulator blends between multiple different pattern algorithms as the clam ages, creating more realistic and varied shell patterns.</p>
                            </div>
                            
                            <div class="tab-panel fashion" id="fashionTab" role="tabpanel" aria-labelledby="fashion-tab">
                                <h3>Fashion Application</h3>
                                <p>The patterns generated here can be downloaded as high-resolution files suitable for fashion design applications. Biomimicry - drawing inspiration from nature's designs - is a powerful approach to sustainable fashion:</p>
                                <ul>
                                    <li><strong>Textile Prints</strong> - Use these organic patterns for fabric designs that celebrate natural forms</li>
                                    <li><strong>Garment Construction</strong> - The concentric growth patterns can inspire layered or paneled garment designs</li>
                                    <li><strong>Color Palettes</strong> - Natural shell gradients provide harmonious color combinations</li>
                                    <li><strong>Sustainable Storytelling</strong> - Connect designs to environmental awareness through nature-inspired patterns</li>
                                </ul>
                                <p>Use the "Download High Resolution Pattern" button to create printable files. Adjust the width, height, and DPI settings to match your desired garment panel dimensions for optimal results in your design software.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <canvas id="fullResCanvas" width="4096" height="4096" class="hidden-canvas"></canvas>
    <div id="statusUpdate" class="sr-status" aria-live="polite"></div>
  <script>
    // DOM elements
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const fullResCanvas = document.getElementById('fullResCanvas');
    const fullResCtx = fullResCanvas.getContext('2d');
    const generateButton = document.getElementById('generateButton');
    const downloadButton = document.getElementById('downloadButton');
    const resetButton = document.getElementById('resetButton');
    const statusUpdate = document.getElementById('statusUpdate');

    // Size and Resolution Controls
    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    const canvasWidthUnit = document.getElementById('canvasWidthUnit');
    const canvasHeightUnit = document.getElementById('canvasHeightUnit');
    const canvasResolution = document.getElementById('canvasResolution');
    const canvasWidthValue = document.getElementById('canvasWidthValue');
    const canvasHeightValue = document.getElementById('canvasHeightValue');
    const canvasResolutionValue = document.getElementById('canvasResolutionValue');

    // Animation controls
    const playPauseButton = document.getElementById('playPauseButton');
    const timelineSlider = document.getElementById('timelineSlider');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const totalTimeDisplay = document.getElementById('totalTimeDisplay');
    const speedButtons = document.querySelectorAll('.speed-btn');
    const ageBands = document.getElementById('ageBands');

    // Pattern blend visualization
    const blendBars = document.getElementById('blendBars');
    const cellularBlendLabel = document.getElementById('cellularBlendLabel');
    const waveBlendLabel = document.getElementById('waveBlendLabel');
    const growthBlendLabel = document.getElementById('growthBlendLabel');
    const voronoiBlendLabel = document.getElementById('voronoiBlendLabel');
    const radialBlendLabel = document.getElementById('radialBlendLabel');

    // Environment history
    const environmentGraph = document.getElementById('environmentGraph');
    const temperatureLine = document.getElementById('temperatureLine');
    const salinityLine = document.getElementById('salinityLine');
    const seasonalLine = document.getElementById('seasonalLine');
    const microplasticLine = document.getElementById('microplasticLine');
    const acidificationLine = document.getElementById('acidificationLine');
    const sedimentLine = document.getElementById('sedimentLine');
    const climateTrend = document.getElementById('climateTrend');

    // Climate scenario
    const climateScenarioSelect = document.getElementById('climateScenario');

    // Growth info
    const growthInfo = document.getElementById('growthInfo');

    // Tab system
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabPanels = document.querySelectorAll('.tab-panel');

    // Input elements and value displays
    const patternTypeSelect = document.getElementById('patternType');
    const patternBlendingInput = document.getElementById('patternBlending');
    const patternBlendingValue = document.getElementById('patternBlendingValue');
    const complexityInput = document.getElementById('complexity');
    const complexityValue = document.getElementById('complexityValue');
    const symmetryInput = document.getElementById('symmetry');
    const symmetryValue = document.getElementById('symmetryValue');
    const temperatureInput = document.getElementById('temperature');
    const temperatureValue = document.getElementById('temperatureValue');
    const salinityInput = document.getElementById('salinity');
    const salinityValue = document.getElementById('salinityValue');
    const sedimentInput = document.getElementById('sediment');
    const sedimentValue = document.getElementById('sedimentValue');
    const acidificationInput = document.getElementById('acidification');
    const acidificationValue = document.getElementById('acidificationValue');
    const microplasticsInput = document.getElementById('microplastics');
    const microplasticsValue = document.getElementById('microplasticsValue');
    const seasonalVariationInput = document.getElementById('seasonalVariation');
    const seasonalVariationValue = document.getElementById('seasonalVariationValue');
    const environmentalEventsInput = document.getElementById('environmentalEvents');
    const environmentalEventsValue = document.getElementById('environmentalEventsValue');
    const growthYearsInput = document.getElementById('growthYears');
    const growthYearsValue = document.getElementById('growthYearsValue');
    const baseColorInput = document.getElementById('baseColor');
    const accentColorInput = document.getElementById('accentColor');
    const microplasticColorInput = document.getElementById('microplasticColor');
    const sedimentColorInput = document.getElementById('sedimentColor');
    const colorVariationInput = document.getElementById('colorVariation');
    const colorVariationValue = document.getElementById('colorVariationValue');

    // Animation state
    let animationState = {
        isPlaying: false,
        speed: 1,
        currentRow: 0,
        totalRows: 0,
        startTime: 0,
        currentTime: 0,
        animationFrameId: null,
        growthYears: 3,
        monthsPerRow: 0,
        environmentalHistory: [],
        growthEvents: [],
        acidificationEvents: [],
        microplasticEvents: [],
        sedimentEvents: [],
        rowsCompleted: 0,
        patternBlend: { cellular: 1, wave: 0, growth: 0, voronoi: 0, radial: 0 },
        climateScenario: 'current',
        symmetryFactor: 0.5, // Control for bilateral symmetry
        sedimentFactor: 0.2   // Control for sediment influence
    };

    // Event listeners for range inputs to update displayed values
    patternBlendingInput.addEventListener('input', () => {
        patternBlendingValue.textContent = patternBlendingInput.value;
    });

    complexityInput.addEventListener('input', () => {
        complexityValue.textContent = complexityInput.value;
    });

    symmetryInput.addEventListener('input', () => {
        symmetryValue.textContent = symmetryInput.value;
    });

    temperatureInput.addEventListener('input', () => {
        temperatureValue.textContent = temperatureInput.value;
    });

    salinityInput.addEventListener('input', () => {
        salinityValue.textContent = salinityInput.value;
    });

    sedimentInput.addEventListener('input', () => {
        sedimentValue.textContent = sedimentInput.value;
    });

    acidificationInput.addEventListener('input', () => {
        acidificationValue.textContent = acidificationInput.value;
    });

    microplasticsInput.addEventListener('input', () => {
        microplasticsValue.textContent = microplasticsInput.value;
    });

    seasonalVariationInput.addEventListener('input', () => {
        seasonalVariationValue.textContent = seasonalVariationInput.value;
    });

    environmentalEventsInput.addEventListener('input', () => {
        environmentalEventsValue.textContent = environmentalEventsInput.value;
    });

    growthYearsInput.addEventListener('input', () => {
        growthYearsValue.textContent = growthYearsInput.value;
        totalTimeDisplay.textContent = `${growthYearsInput.value}y 0m`;
    });

    colorVariationInput.addEventListener('input', () => {
        colorVariationValue.textContent = colorVariationInput.value;
    });

    // Canvas size and resolution controls
    canvasWidthInput.addEventListener('input', () => {
        canvasWidthValue.textContent = canvasWidthInput.value;
        updateCanvasDimensions();
    });
    
    canvasHeightInput.addEventListener('input', () => {
        canvasHeightValue.textContent = canvasHeightInput.value;
        updateCanvasDimensions();
    });
    
    canvasResolution.addEventListener('input', () => {
        canvasResolutionValue.textContent = canvasResolution.value;
    });
    
    canvasWidthUnit.addEventListener('change', updateCanvasDimensions);
    canvasHeightUnit.addEventListener('change', updateCanvasDimensions);

    // Function to update canvas dimensions preview
    function updateCanvasDimensions() {
        const width = parseInt(canvasWidthInput.value);
        const height = parseInt(canvasHeightInput.value);
        const widthUnit = canvasWidthUnit.value;
        const heightUnit = canvasHeightUnit.value;
        
        // Update dimension labels
        canvasWidthValue.textContent = `${width}${widthUnit}`;
        canvasHeightValue.textContent = `${height}${heightUnit}`;
        
        // Update aspect ratio of preview canvas
        const aspectRatio = width / height;
        previewCanvas.style.aspectRatio = aspectRatio;
        
        // Update status for screen readers
        statusUpdate.textContent = `Canvas size updated to ${width}${widthUnit} √ó ${height}${heightUnit}`;
    }

    // Climate scenario change event
    climateScenarioSelect.addEventListener('change', () => {
        // Update environmental parameters based on climate scenario
        updateClimateScenarioParameters();
    });

    // Button event listeners
    generateButton.addEventListener('click', startNewSimulation);
    downloadButton.addEventListener('click', downloadFullResolution);
    resetButton.addEventListener('click', resetParameters);

    // Animation control event listeners
    playPauseButton.addEventListener('click', togglePlayPause);
    timelineSlider.addEventListener('input', scrubTimeline);

    // Tab system event listeners
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Remove active class from all buttons and panels
            tabButtons.forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-selected', 'false');
            });
            tabPanels.forEach(panel => panel.classList.remove('active'));
            
            // Add active class to clicked button
            button.classList.add('active');
            button.setAttribute('aria-selected', 'true');
            
            // Show corresponding panel
            const tabId = button.getAttribute('data-tab');
            document.getElementById(`${tabId}Tab`).classList.add('active');
        });
    });

    // Speed button event listeners
    speedButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Remove active class from all buttons
            speedButtons.forEach(b => b.classList.remove('active'));
            
            // Add active class to clicked button
            button.classList.add('active');
            
            // Set animation speed
            animationState.speed = parseFloat(button.dataset.speed);
        });
    });

    // Generate pattern when page loads
    window.addEventListener('DOMContentLoaded', () => {
        setTimeout(initializeSimulation, 100);
    });
    // Update climate scenario parameters for UK waters
    function updateClimateScenarioParameters() {
        const scenario = climateScenarioSelect.value;
        animationState.climateScenario = scenario;
        
        // Adjust parameters based on climate scenario - UK specific
        switch (scenario) {
            case 'pre-industrial':
                // Pre-industrial: minimal pollution, stable climate
                microplasticsInput.value = 0;
                microplasticsValue.textContent = 0;
                acidificationInput.value = 0;
                acidificationValue.textContent = 0;
                sedimentInput.value = 15;
                sedimentValue.textContent = 15;
                seasonalVariationInput.value = 30;
                seasonalVariationValue.textContent = 30;
                temperatureInput.value = 13;
                temperatureValue.textContent = 13;
                break;
                
            case 'current':
                // Current: moderate pollution, UK conditions
                microplasticsInput.value = 15;
                microplasticsValue.textContent = 15;
                acidificationInput.value = 20;
                acidificationValue.textContent = 20;
                sedimentInput.value = 20;
                sedimentValue.textContent = 20;
                seasonalVariationInput.value = 40;
                seasonalVariationValue.textContent = 40;
                temperatureInput.value = 14;
                temperatureValue.textContent = 14;
                break;
                
            case 'near-future':
                // Near-future UK: higher pollution, more variability
                microplasticsInput.value = 45;
                microplasticsValue.textContent = 45;
                acidificationInput.value = 50;
                acidificationValue.textContent = 50;
                sedimentInput.value = 35;
                sedimentValue.textContent = 35;
                seasonalVariationInput.value = 65;
                seasonalVariationValue.textContent = 65;
                temperatureInput.value = 16;
                temperatureValue.textContent = 16;
                break;
                
            case 'worst-case':
                // Worst-case UK 2100: severe pollution, extreme variability
                microplasticsInput.value = 75;
                microplasticsValue.textContent = 75;
                acidificationInput.value = 80;
                acidificationValue.textContent = 80;
                sedimentInput.value = 60;
                sedimentValue.textContent = 60;
                seasonalVariationInput.value = 85;
                seasonalVariationValue.textContent = 85;
                temperatureInput.value = 19;
                temperatureValue.textContent = 19;
                break;
        }
        
        // Update status with accessibility in mind
        statusUpdate.textContent = `Climate scenario updated to ${formatClimateScenario(scenario)}`;
    }

    // Reset parameters to default values - UK specific
    function resetParameters() {
        patternTypeSelect.value = 'cellular';
        patternBlendingInput.value = 50;
        patternBlendingValue.textContent = 50;
        complexityInput.value = 50;
        complexityValue.textContent = 50;
        symmetryInput.value = 50;
        symmetryValue.textContent = 50;
        climateScenarioSelect.value = 'current';
        temperatureInput.value = 14;
        temperatureValue.textContent = 14;
        salinityInput.value = 32;
        salinityValue.textContent = 32;
        sedimentInput.value = 20;
        sedimentValue.textContent = 20;
        acidificationInput.value = 20;
        acidificationValue.textContent = 20;
        microplasticsInput.value = 15;
        microplasticsValue.textContent = 15;
        seasonalVariationInput.value = 40;
        seasonalVariationValue.textContent = 40;
        environmentalEventsInput.value = 3;
        environmentalEventsValue.textContent = 3;
        growthYearsInput.value = 3;
        growthYearsValue.textContent = 3;
        baseColorInput.value = '#e8d6b3';
        accentColorInput.value = '#6a4c3b';
        microplasticColorInput.value = '#9370DB';
        sedimentColorInput.value = '#a08563';
        colorVariationInput.value = 30;
        colorVariationValue.textContent = 30;
        canvasWidthInput.value = 30;
        canvasWidthValue.textContent = 30;
        canvasHeightInput.value = 30;
        canvasHeightValue.textContent = 30;
        canvasWidthUnit.value = 'cm';
        canvasHeightUnit.value = 'cm';
        canvasResolution.value = 150;
        canvasResolutionValue.textContent = 150;
        
        // Update canvas dimensions
        updateCanvasDimensions();
        
        statusUpdate.textContent = "Parameters reset to UK-specific default values";
        startNewSimulation();
    }

    // Format climate scenario for display
    function formatClimateScenario(scenario) {
        switch (scenario) {
            case 'pre-industrial':
                return 'Pre-Industrial';
            case 'current':
                return 'Current UK Waters';
            case 'near-future':
                return 'Near-Future UK (2050)';
            case 'worst-case':
                return 'Worst-Case UK (2100)';
            default:
                return scenario;
        }
    }

    // Initialize the simulation
    function initializeSimulation() {
        // Clear animation if already running
        if (animationState.animationFrameId) {
            cancelAnimationFrame(animationState.animationFrameId);
        }
        
        // Set up initial state
        animationState.isPlaying = false;
        animationState.currentRow = 0;
        animationState.totalRows = previewCanvas.height;
        animationState.growthYears = parseInt(growthYearsInput.value);
        animationState.monthsPerRow = (animationState.growthYears * 12) / animationState.totalRows;
        animationState.environmentalHistory = [];
        animationState.growthEvents = [];
        animationState.acidificationEvents = [];
        animationState.microplasticEvents = [];
        animationState.sedimentEvents = [];
        animationState.rowsCompleted = 0;
        animationState.climateScenario = climateScenarioSelect.value;
        animationState.symmetryFactor = parseInt(symmetryInput.value) / 100;
        animationState.sedimentFactor = parseInt(sedimentInput.value) / 100;
        
        // Initialize pattern blend based on selected pattern type
        initializePatternBlend();
        
        // Update UI
        updatePlayPauseButton();
        timelineSlider.value = 0;
        timelineSlider.max = animationState.totalRows;
        currentTimeDisplay.textContent = formatTimeDisplay(0);
        totalTimeDisplay.textContent = formatTimeDisplay(animationState.totalRows);
        
        // Clear canvas
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // Initialize pattern generation
        initializePatternGeneration();
        
        // Generate environmental events - UK specific
        generateUKEnvironmentalEvents();
        
        // Generate acidification events
        generateAcidificationEvents();
        
        // Generate microplastic events
        generateMicroplasticEvents();
        
        // Generate sediment events
        generateSedimentEvents();
        
        // Create age bands
        createAgeBands();
        
        // Update growth info
        updateGrowthInfo(0);
        
        // Update pattern blend visualization
        updatePatternBlendVisualization(0);
        
        // Draw first row
        drawNextRow();
        
        // Update environment graph
        updateEnvironmentGraph();
    }

    // Generate UK-specific environmental events
    function generateUKEnvironmentalEvents() {
        const eventCount = parseInt(environmentalEventsInput.value);
        const totalRows = animationState.totalRows;
        const climateScenario = animationState.climateScenario;
        
        // Clear existing events
        animationState.growthEvents = [];
        
        // If no events, return
        if (eventCount === 0) return;
        
        // UK-specific events by scenario
        let ukEventTypes = [];
        switch (climateScenario) {
            case 'pre-industrial':
                ukEventTypes = ['mild_temperature', 'mild_storm', 'mild_salinity', 'mild_sediment'];
                break;
            case 'current':
                ukEventTypes = ['temperature', 'storm', 'algal_bloom', 'salinity', 'pollution', 'sediment'];
                break;
            case 'near-future':
                ukEventTypes = ['temperature', 'severe_storm', 'algal_bloom', 'salinity', 'pollution', 'heavy_sediment'];
                break;
            case 'worst-case':
                ukEventTypes = ['extreme_temperature', 'severe_storm', 'toxic_bloom', 'extreme_salinity', 'pollution', 'extreme_sediment'];
                break;
        }
        
        // Generate random events
        for (let i = 0; i < eventCount; i++) {
            // Random event type from scenario-appropriate list
            const type = ukEventTypes[Math.floor(Math.random() * ukEventTypes.length)];
            
            // Random event timing and duration
            const startRow = Math.floor(Math.random() * (totalRows * 0.9)); // Start in first 90% of rows
            const duration = Math.floor((totalRows * 0.05) + (Math.random() * totalRows * 0.15)); // 5-20% of total rows
            const endRow = Math.min(startRow + duration, totalRows - 1);
            const peakRow = startRow + Math.floor(duration / 2); // Peak in the middle
            
            // Random intensity (0.2 to 1.0)
            const intensity = 0.2 + (Math.random() * 0.8);
            
            // Create event object
            const event = {
                type,
                startRow,
                endRow,
                peakRow,
                intensity,
                name: getUKEventName(type, intensity),
                description: getUKEventDescription(type, intensity, animationState.climateScenario)
            };
            
            // Add to events array
            animationState.growthEvents.push(event);
        }
        
        // Sort events by start row
        animationState.growthEvents.sort((a, b) => a.startRow - b.startRow);
    }

    // Generate sediment events - UK specific
    function generateSedimentEvents() {
        const climateScenario = animationState.climateScenario;
        const totalRows = animationState.totalRows;
        
        // Clear existing events
        animationState.sedimentEvents = [];
        
        // Number of events depends on climate scenario
        let eventCount = 0;
        switch (climateScenario) {
            case 'pre-industrial':
                eventCount = 1; // Rare sediment events
                break;
            case 'current':
                eventCount = 2; // Occasional sediment events in UK waters
                break;
            case 'near-future':
                eventCount = 3; // More frequent sediment events by 2050
                break;
            case 'worst-case':
                eventCount = 5; // Severe and frequent sediment events by 2100
                break;
        }
        
        // Generate sediment events
        for (let i = 0; i < eventCount; i++) {
            // Random event timing and duration
            const startRow = Math.floor(Math.random() * (totalRows * 0.9));
            const duration = Math.floor((totalRows * 0.05) + (Math.random() * totalRows * 0.15));
            const endRow = Math.min(startRow + duration, totalRows - 1);
            const peakRow = startRow + Math.floor(duration / 2);
            
            // Intensity depends on climate scenario
            let baseIntensity = 0;
            switch (climateScenario) {
                case 'pre-industrial':
                    baseIntensity = 0.1 + (Math.random() * 0.2); // 0.1-0.3
                    break;
                case 'current':
                    baseIntensity = 0.2 + (Math.random() * 0.3); // 0.2-0.5
                    break;
                case 'near-future':
                    baseIntensity = 0.4 + (Math.random() * 0.3); // 0.4-0.7
                    break;
                case 'worst-case':
                    baseIntensity = 0.6 + (Math.random() * 0.4); // 0.6-1.0
                    break;
            }
            
            // Create event object with UK-specific descriptions
            const event = {
                type: 'sediment',
                startRow,
                endRow,
                peakRow,
                intensity: baseIntensity,
                name: `${baseIntensity < 0.3 ? 'Mild' : baseIntensity < 0.6 ? 'Moderate' : 'Severe'} Sediment Influx`,
                description: getUKSedimentDescription(baseIntensity, climateScenario)
            };
            
            // Add to events array
            animationState.sedimentEvents.push(event);
        }
        
        // Sort events by start row
        animationState.sedimentEvents.sort((a, b) => a.startRow - b.startRow);
    }

    // Get UK-specific sediment event description
    function getUKSedimentDescription(intensity, climateScenario) {
        let prefix = '';
        
        // Add climate scenario context
        if (climateScenario === 'near-future') {
            prefix = 'Due to increased UK rainfall patterns by 2050, ';
        } else if (climateScenario === 'worst-case') {
            prefix = 'Under extreme coastal erosion projections for UK by 2100, ';
        }
        
        if (intensity < 0.3) {
            return prefix + 'mild sediment influx from typical UK river flow creates subtle surface texturing on the shell.';
        } else if (intensity < 0.6) {
            return prefix + 'moderate sediment influx from UK coastal runoff alters shell pattern development, creating distinct banding.';
        } else {
            return prefix + 'heavy sediment load from flooding events disrupts normal shell formation, creating significant textural anomalies.';
        }
    }

    // Get UK-specific event name based on type and intensity
    function getUKEventName(type, intensity) {
        const intensityLabel = intensity < 0.4 ? 'Mild' : intensity < 0.7 ? 'Moderate' : 'Severe';
        
        switch (type) {
            case 'mild_temperature':
                return `${intensityLabel} Seasonal Warming`;
            case 'temperature':
                return `${intensityLabel} Temperature Change`;
            case 'extreme_temperature':
                return `Extreme Heatwave`;
            case 'mild_storm':
                return `${intensityLabel} Weather Event`;
            case 'storm':
                return `${intensityLabel} UK Storm`;
            case 'severe_storm':
                return `Named Storm System`;
            case 'mild_salinity':
                return `${intensityLabel} Rainfall Event`;
            case 'salinity':
                return `${intensityLabel} Salinity Shift`;
            case 'extreme_salinity':
                return `Extreme Freshwater Input`;
            case 'algal_bloom':
                return `${intensityLabel} Algal Bloom`;
            case 'toxic_bloom':
                return `Toxic Algal Bloom`;
            case 'pollution':
                return `${intensityLabel} Pollution Event`;
            case 'mild_sediment':
                return `${intensityLabel} Sediment Influx`;
            case 'sediment':
                return `${intensityLabel} Sediment Change`;
            case 'heavy_sediment':
                return `Heavy Sediment Load`;
            case 'extreme_sediment':
                return `Extreme Sediment Event`;
            default:
                return 'Environmental Event';
        }
    }
    // Get UK-specific event description based on type and intensity
    function getUKEventDescription(type, intensity, climateScenario) {
        let prefix = '';
        
        // Add climate scenario context
        if (climateScenario === 'near-future' && (type.includes('temperature') || type.includes('storm'))) {
            prefix = 'As projected for 2050s UK coastal waters, a ';
        } else if (climateScenario === 'worst-case' && (type.includes('extreme') || type.includes('toxic'))) {
            prefix = 'In this extreme climate scenario for UK waters by 2100, a ';
        }
        
        switch (type) {
            case 'mild_temperature':
                return 'Typical UK seasonal warming affects shell growth rate slightly.';
            
            case 'temperature':
                if (intensity < 0.4) {
                    return prefix + 'milder than average summer period affects shell growth rate.';
                } else if (intensity < 0.7) {
                    return prefix + 'significant warming event in UK waters accelerates shell growth and alters pattern formation.';
                } else {
                    return prefix + 'UK marine heatwave significantly increases metabolism and alters growth patterns.';
                }
            
            case 'extreme_temperature':
                return prefix + 'prolonged extreme marine heatwave causes physiological stress and disrupts normal shell formation.';
            
            case 'mild_storm':
                return 'Typical UK weather pattern brings rainfall and slight temperature changes.';
            
            case 'storm':
                if (intensity < 0.4) {
                    return 'Minor UK storm brings fresh water runoff and temperature drop.';
                } else if (intensity < 0.7) {
                    return 'Significant autumn/winter storm disrupts normal growth with temperature and salinity changes typical of UK coastal waters.';
                } else {
                    return 'Major storm event brings substantial freshwater input to the estuary, creating a distinctive growth interruption.';
                }
            
            case 'severe_storm':
                return prefix + 'named storm system causes major disruption to coastal habitats with significant freshwater influx and sediment resuspension.';
            
            case 'mild_salinity':
                return 'Normal seasonal rainfall affects estuarine salinity levels.';
            
            case 'salinity':
                if (intensity < 0.4) {
                    return 'A slight change in salinity due to rainfall affects shell mineralization.';
                } else if (intensity < 0.7) {
                    return 'Moderate salinity change from prolonged precipitation alters the shell pattern definition.';
                } else {
                    return 'Dramatic salinity shift from flooding causes stress and creates distinct pattern banding.';
                }
            
            case 'extreme_salinity':
                return prefix + 'extreme flooding event dramatically lowers salinity in the estuary, severely stressing the clam and creating a distinct stress band in the shell.';
            
            case 'algal_bloom':
                if (intensity < 0.5) {
                    return 'Seasonal algal bloom provides abundant food, increasing growth rate temporarily.';
                } else {
                    return 'Large algal bloom depletes oxygen when it dies off, temporarily slowing growth and affecting shell density.';
                }
            
            case 'toxic_bloom':
                return prefix + 'harmful algal bloom produces toxins that disrupt the shell formation process, creating distinctive pattern abnormalities.';
            
            case 'pollution':
                if (intensity < 0.4) {
                    return 'Minor pollution event from coastal runoff affects shell coloration slightly.';
                } else if (intensity < 0.7) {
                    return 'Moderate pollution from agricultural or urban runoff disrupts normal shell formation.';
                } else {
                    return 'Significant pollution event causes visible disruption to shell growth and pattern formation.';
                }
            
            case 'mild_sediment':
                return 'Slight increase in suspended sediment from tidal action creates subtle texture on the shell surface.';
                
            case 'sediment':
                if (intensity < 0.4) {
                    return 'Minor sediment influx from seasonal riverflow affects shell texture formation.';
                } else if (intensity < 0.7) {
                    return 'Moderate increase in sediment load creates distinctive texture bands in the shell pattern.';
                } else {
                    return 'Significant sediment influx from coastal erosion or river discharge dramatically affects shell pattern and texture.';
                }
                
            case 'heavy_sediment':
                return prefix + 'substantial increase in sediment load from increased precipitation disrupts normal shell growth, creating distinctive texture and pattern variations.';
                
            case 'extreme_sediment':
                return prefix + 'extreme erosion event leads to massive sediment influx, severely affecting shell formation and creating highly irregular patterns.';
            
            default:
                return 'Environmental conditions in UK waters changed, affecting shell growth.';
        }
    }

    // Generate acidification events - UK specific
    function generateAcidificationEvents() {
        const climateScenario = animationState.climateScenario;
        const totalRows = animationState.totalRows;
        
        // Clear existing events
        animationState.acidificationEvents = [];
        
        // Number of events depends on climate scenario
        let eventCount = 0;
        switch (climateScenario) {
            case 'pre-industrial':
                eventCount = 0; // No acidification events
                break;
            case 'current':
                eventCount = 1; // Occasional acidification event in UK waters
                break;
            case 'near-future':
                eventCount = 2; // More frequent acidification events by 2050
                break;
            case 'worst-case':
                eventCount = 4; // Severe and frequent acidification events by 2100
                break;
        }
        
        // If no events, return
        if (eventCount === 0) return;
        
        // Generate acidification events
        for (let i = 0; i < eventCount; i++) {
            // Random event timing and duration
            const startRow = Math.floor(Math.random() * (totalRows * 0.9)); // Start in first 90% of rows
            const duration = Math.floor((totalRows * 0.08) + (Math.random() * totalRows * 0.15)); // 8-23% of total rows
            const endRow = Math.min(startRow + duration, totalRows - 1);
            const peakRow = startRow + Math.floor(duration / 2); // Peak in the middle
            
            // Intensity depends on climate scenario
            let baseIntensity = 0;
            switch (climateScenario) {
                case 'current':
                    baseIntensity = 0.2 + (Math.random() * 0.2); // 0.2-0.4
                    break;
                case 'near-future':
                    baseIntensity = 0.4 + (Math.random() * 0.3); // 0.4-0.7
                    break;
                case 'worst-case':
                    baseIntensity = 0.6 + (Math.random() * 0.4); // 0.6-1.0
                    break;
            }
            
            // Create event object with UK-specific descriptions
            const event = {
                type: 'acidification',
                startRow,
                endRow,
                peakRow,
                intensity: baseIntensity,
                name: `${baseIntensity < 0.4 ? 'Mild' : baseIntensity < 0.7 ? 'Moderate' : 'Severe'} UK Waters Acidification`,
                description: getUKAcidificationDescription(baseIntensity, climateScenario)
            };
            
            // Add to events array
            animationState.acidificationEvents.push(event);
        }
        
        // Sort events by start row
        animationState.acidificationEvents.sort((a, b) => a.startRow - b.startRow);
    }

    // Get UK-specific acidification event description
    function getUKAcidificationDescription(intensity, climateScenario) {
        let prefix = '';
        
        // Add climate scenario context for near-future and worst-case
        if (climateScenario === 'near-future') {
            prefix = 'Due to projected UK coastal water pH changes by 2050, ';
        } else if (climateScenario === 'worst-case') {
            prefix = 'In this extreme acidification scenario for UK waters by 2100, ';
        }
        
        if (intensity < 0.4) {
            return prefix + 'mild pH decrease causes slight shell thinning in UK waters.';
        } else if (intensity < 0.7) {
            return prefix + 'moderate acidification in UK coastal waters disrupts calcium carbonate deposition, causing pattern irregularities.';
        } else {
            return prefix + 'severe acidification event significantly weakens shell structure, creating visible disruptions typical of extreme climate scenarios.';
        }
    }

    // Generate microplastic events - UK specific
    function generateMicroplasticEvents() {
        const climateScenario = animationState.climateScenario;
        const totalRows = animationState.totalRows;
        
        // Clear existing events
        animationState.microplasticEvents = [];
        
        // Number of events depends on climate scenario
        let eventCount = 0;
        switch (climateScenario) {
            case 'pre-industrial':
                eventCount = 0; // No microplastic events
                break;
            case 'current':
                eventCount = 2; // Current UK coastal pollution levels
                break;
            case 'near-future':
                eventCount = 3; // Near-future projections for UK waters
                break;
            case 'worst-case':
                eventCount = 5; // Worst-case scenario for UK waters
                break;
        }
        
        // If no events, return
        if (eventCount === 0) return;
        
        // Generate microplastic events
        for (let i = 0; i < eventCount; i++) {
            // Random event timing and duration
            const startRow = Math.floor(Math.random() * (totalRows * 0.9)); // Start in first 90% of rows
            const duration = Math.floor((totalRows * 0.05) + (Math.random() * totalRows * 0.1)); // 5-15% of total rows
            const endRow = Math.min(startRow + duration, totalRows - 1);
            const peakRow = startRow + Math.floor(duration / 2); // Peak in the middle
            
            // Intensity depends on climate scenario
            let baseIntensity = 0;
            switch (climateScenario) {
                case 'current':
                    baseIntensity = 0.3 + (Math.random() * 0.2); // 0.3-0.5
                    break;
                case 'near-future':
                    baseIntensity = 0.4 + (Math.random() * 0.3); // 0.4-0.7
                    break;
                case 'worst-case':
                    baseIntensity = 0.5 + (Math.random() * 0.5); // 0.5-1.0
                    break;
            }
            
            // Create event object with UK-specific names and descriptions
            const event = {
                type: 'microplastic',
                startRow,
                endRow,
                peakRow,
                intensity: baseIntensity,
                name: `${baseIntensity < 0.4 ? 'Low' : baseIntensity < 0.7 ? 'Moderate' : 'High'} UK Microplastic Event`,
                description: getUKMicroplasticDescription(baseIntensity, climateScenario)
            };
            
            // Add to events array
            animationState.microplasticEvents.push(event);
        }
        
        // Sort events by start row
        animationState.microplasticEvents.sort((a, b) => a.startRow - b.startRow);
    }

    // Get UK-specific microplastic event description
    function getUKMicroplasticDescription(intensity, climateScenario) {
        let baseDescription = "";
        
        if (intensity < 0.4) {
            baseDescription = "Low-level microplastic contamination from UK coastal waters appears in the shell structure.";
        } else if (intensity < 0.7) {
            baseDescription = "Moderate microplastic pollution from UK rivers and estuaries is incorporated into the shell, creating small abnormalities.";
        } else {
            baseDescription = "Severe microplastic contamination from urban runoff and wastewater causes significant incorporation of particles into shell structure.";
        }
        
        // Add climate scenario context
        if (climateScenario === 'near-future') {
            return `Projected for UK waters by 2050: ${baseDescription}`;
        } else if (climateScenario === 'worst-case') {
            return `In a worst-case scenario for UK marine pollution by 2100: ${baseDescription}`;
        }
        
        return baseDescription;
    }

    // Start a new simulation
    function startNewSimulation() {
        // Update full resolution canvas based on user dimensions and resolution
        updateFullResolutionCanvas();
        
        // Initialize the simulation
        initializeSimulation();
        statusUpdate.textContent = "New growth simulation initialized. Press play to begin.";
    }

    // Update full resolution canvas size based on user inputs
    function updateFullResolutionCanvas() {
        const width = parseInt(canvasWidthInput.value);
        const height = parseInt(canvasHeightInput.value);
        const dpi = parseInt(canvasResolution.value);
        const widthUnit = canvasWidthUnit.value;
        const heightUnit = canvasHeightUnit.value;
        
        // Convert dimensions to pixels
        let widthPx, heightPx;
        
        if (widthUnit === 'cm') {
            widthPx = Math.round(width * dpi / 2.54); // cm to inches, then to pixels
        } else {
            widthPx = Math.round(width * dpi); // inches to pixels
        }
        
        if (heightUnit === 'cm') {
            heightPx = Math.round(height * dpi / 2.54); // cm to inches, then to pixels
        } else {
            heightPx = Math.round(height * dpi); // inches to pixels
        }
        
        // Cap at maximum dimensions (to prevent browser crashes)
        const maxDimension = 8192;
        if (widthPx > maxDimension || heightPx > maxDimension) {
            const scaleFactor = Math.min(maxDimension / widthPx, maxDimension / heightPx);
            widthPx = Math.round(widthPx * scaleFactor);
            heightPx = Math.round(heightPx * scaleFactor);
            
            statusUpdate.textContent = "Dimensions exceeded maximum size. Scaled down to preserve aspect ratio.";
        }
        
        // Update full resolution canvas dimensions
        fullResCanvas.width = widthPx;
        fullResCanvas.height = heightPx;
        
        // Log dimensions for debugging
        console.log(`Full resolution canvas size: ${widthPx}px √ó ${heightPx}px at ${dpi} DPI`);
    }

    // Toggle play/pause
    function togglePlayPause() {
        animationState.isPlaying = !animationState.isPlaying;
        
        if (animationState.isPlaying) {
            // Start animation
            animationState.startTime = performance.now() - (animationState.currentRow * 50 / animationState.speed);
            animateGrowth();
            playPauseButton.setAttribute('aria-label', 'Pause animation');
        } else {
            // Pause animation
            if (animationState.animationFrameId) {
                cancelAnimationFrame(animationState.animationFrameId);
                animationState.animationFrameId = null;
            }
            playPauseButton.setAttribute('aria-label', 'Play animation');
        }
        
        updatePlayPauseButton();
    }

    // Update play/pause button
    function updatePlayPauseButton() {
        if (animationState.isPlaying) {
            playPauseButton.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <rect x="6" y="4" width="4" height="16" fill="currentColor"></rect>
                    <rect x="14" y="4" width="4" height="16" fill="currentColor"></rect>
                </svg>
            `;
        } else {
            playPauseButton.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <polygon points="5 3 19 12 5 21 5 3" fill="currentColor"></polygon>
                </svg>
            `;
        }
    }
    // Scrub timeline
    function scrubTimeline() {
        const targetRow = parseInt(timelineSlider.value);
        
        // If we're going backward, we need to reset and redraw up to the target
        if (targetRow < animationState.currentRow) {
            initializePatternGeneration();
            animationState.currentRow = 0;
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // Draw rows up to target
            for (let i = 0; i <= targetRow; i++) {
                updatePatternBlend(i);
                drawNextRow();
            }
        } else {
            // Draw any new rows needed to reach target
            while (animationState.currentRow < targetRow) {
                updatePatternBlend(animationState.currentRow);
                drawNextRow();
            }
        }
        
        // Update time display
        currentTimeDisplay.textContent = formatTimeDisplay(animationState.currentRow);
        
        // Update growth info for this point in time
        updateGrowthInfo(animationState.currentRow);
        
        // Update environment graph with current time marker
        updateEnvironmentGraph(animationState.currentRow);
        
        // Update age bands
        updateAgeBands(animationState.currentRow);
        
        // Update pattern blend visualization
        updatePatternBlendVisualization(animationState.currentRow);
    }

    // Animate growth
    function animateGrowth() {
        if (!animationState.isPlaying) return;
        
        const now = performance.now();
        const elapsed = now - animationState.startTime;
        const targetRow = Math.min(
            Math.floor(elapsed * animationState.speed / 50), 
            animationState.totalRows
        );
        
        if (targetRow > animationState.currentRow) {
            // Draw new rows
            for (let i = animationState.currentRow; i < targetRow; i++) {
                updatePatternBlend(i);
                drawNextRow();
            }
            
            // Update timeline slider
            timelineSlider.value = animationState.currentRow;
            
            // Update time display
            currentTimeDisplay.textContent = formatTimeDisplay(animationState.currentRow);
            
            // Update growth info
            updateGrowthInfo(animationState.currentRow);
            
            // Update environment graph
            updateEnvironmentGraph(animationState.currentRow);
            
            // Update age bands
            updateAgeBands(animationState.currentRow);
            
            // Update pattern blend visualization
            updatePatternBlendVisualization(animationState.currentRow);
        }
        
        // Check if animation is complete
        if (animationState.currentRow >= animationState.totalRows) {
            // Animation complete
            animationState.isPlaying = false;
            updatePlayPauseButton();
            statusUpdate.textContent = "Growth simulation complete. Pattern is ready for high resolution export.";
            
            // Generate full resolution image
            generateFullResolutionPattern();
            
            return;
        }
        
        // Continue animation
        animationState.animationFrameId = requestAnimationFrame(animateGrowth);
    }

    // Format time display (convert rows to years and months)
    function formatTimeDisplay(rows) {
        const totalMonths = Math.floor(rows * animationState.monthsPerRow);
        const years = Math.floor(totalMonths / 12);
        const months = totalMonths % 12;
        
        return `${years}y ${months}m`;
    }

    // Initialize pattern blend based on selected pattern type
    function initializePatternBlend() {
        const patternType = patternTypeSelect.value;
        
        // Reset all blend values
        animationState.patternBlend = {
            cellular: 0,
            wave: 0,
            growth: 0,
            voronoi: 0,
            radial: 0
        };
        
        // Set primary pattern type to 100%
        animationState.patternBlend[patternType] = 1;
    }

    // Update pattern blend based on clam age and environmental factors
    function updatePatternBlend(row) {
        const age = row / animationState.totalRows; // Normalized age (0-1)
        const patternBlendingFactor = parseInt(patternBlendingInput.value) / 100; // How much blending occurs (0-1)
        const startingPattern = patternTypeSelect.value; // Initial dominant pattern
        
        // If blending is disabled, keep the initial pattern
        if (patternBlendingFactor === 0) {
            // Reset all blend values
            animationState.patternBlend = {
                cellular: 0,
                wave: 0,
                growth: 0,
                voronoi: 0,
                radial: 0
            };
            animationState.patternBlend[startingPattern] = 1;
            return;
        }
        
        // Base pattern evolution for Manila clam shells:
        // - Younger clams favor cellular patterns (rapid growth)
        // - Middle-aged clams favor wave and voronoi patterns (stable growth)
        // - Older clams favor growth rings and radial patterns (slower, more defined growth)
        let cellularWeight = Math.max(0, 1 - (age * 2)); // Dominant when young
        let waveWeight = Math.sin(Math.PI * age); // Peaks in middle age
        let growthWeight = Math.min(1, age * 2); // Increases with age
        let voronoiWeight = Math.sin(Math.PI * age * 0.8) * 0.8; // Peaks in middle-late age
        let radialWeight = Math.min(1, age * 1.6) * 0.7; // Increases gradually with age
        
        // Adjust weights based on starting pattern to make that pattern more prominent
        switch (startingPattern) {
            case 'cellular':
                cellularWeight *= 1.5;
                break;
            case 'wave':
                waveWeight *= 1.5;
                break;
            case 'growth':
                growthWeight *= 1.5;
                break;
            case 'voronoi':
                voronoiWeight *= 1.5;
                break;
            case 'radial':
                radialWeight *= 1.5;
                break;
        }
        
        // Get current environmental parameters
        const params = getCurrentEnvironmentalParams(row);
        
        // Environmental modifiers - UK-specific
        if (params.temperature > 18) {
            // Stress pattern changes during extreme heat in UK waters - favors cellular (chaotic) growth
            cellularWeight += 0.3;
            growthWeight -= 0.2;
        }
        
        if (params.acidification > 0.5) {
            // Acidification disrupts ordered growth - favors more chaotic patterns
            cellularWeight += 0.2;
            waveWeight -= 0.1;
            growthWeight -= 0.1;
        }
        
        if (params.microplastics > 0.7) {
            // High microplastic contamination affects pattern development
            voronoiWeight += 0.3;
            radialWeight -= 0.2;
        }
        
        if (params.sediment > 0.6) {
            // High sediment levels affect texture and pattern development
            voronoiWeight += 0.2;
            cellularWeight += 0.1;
            growthWeight -= 0.2;
        }
        
        // Apply pattern blending factor - smooth transition between states
        cellularWeight = (1 - patternBlendingFactor) * animationState.patternBlend.cellular + patternBlendingFactor * cellularWeight;
        waveWeight = (1 - patternBlendingFactor) * animationState.patternBlend.wave + patternBlendingFactor * waveWeight;
        growthWeight = (1 - patternBlendingFactor) * animationState.patternBlend.growth + patternBlendingFactor * growthWeight;
        voronoiWeight = (1 - patternBlendingFactor) * animationState.patternBlend.voronoi + patternBlendingFactor * voronoiWeight;
        radialWeight = (1 - patternBlendingFactor) * animationState.patternBlend.radial + patternBlendingFactor * radialWeight;
        
        // Normalize weights to sum to 1
        const totalWeight = cellularWeight + waveWeight + growthWeight + voronoiWeight + radialWeight;
        if (totalWeight > 0) {
            cellularWeight /= totalWeight;
            waveWeight /= totalWeight;
            growthWeight /= totalWeight;
            voronoiWeight /= totalWeight;
            radialWeight /= totalWeight;
        } else {
            // Fallback if all weights are zero
            cellularWeight = 1;
            waveWeight = 0;
            growthWeight = 0;
            voronoiWeight = 0;
            radialWeight = 0;
        }
        
        // Update pattern blend
        animationState.patternBlend = {
            cellular: cellularWeight,
            wave: waveWeight,
            growth: growthWeight,
            voronoi: voronoiWeight,
            radial: radialWeight
        };
    }

    // Update pattern blend visualization
    function updatePatternBlendVisualization(row) {
        // Get current pattern blend
        const { cellular, wave, growth, voronoi, radial } = animationState.patternBlend;
        
        // Update bars
        const cellularBar = blendBars.querySelector('.blend-bar.cellular');
        const waveBar = blendBars.querySelector('.blend-bar.wave');
        const growthBar = blendBars.querySelector('.blend-bar.growth');
        const voronoiBar = blendBars.querySelector('.blend-bar.voronoi');
        const radialBar = blendBars.querySelector('.blend-bar.radial');
        
        cellularBar.style.width = `${cellular * 100}%`;
        waveBar.style.width = `${wave * 100}%`;
        growthBar.style.width = `${growth * 100}%`;
        voronoiBar.style.width = `${voronoi * 100}%`;
        radialBar.style.width = `${radial * 100}%`;
        
        // Update labels
        cellularBlendLabel.textContent = `Cellular: ${Math.round(cellular * 100)}%`;
        waveBlendLabel.textContent = `Wave: ${Math.round(wave * 100)}%`;
        growthBlendLabel.textContent = `Growth: ${Math.round(growth * 100)}%`;
        voronoiBlendLabel.textContent = `Voronoi: ${Math.round(voronoi * 100)}%`;
        radialBlendLabel.textContent = `Radial: ${Math.round(radial * 100)}%`;
    }

    // Generate full resolution pattern for fashion application
    function generateFullResolutionPattern() {
        try {
            // Clear canvas
            fullResCtx.clearRect(0, 0, fullResCanvas.width, fullResCanvas.height);
            
            // Create a scaled version of the preview canvas
            const scaleFactorX = fullResCanvas.width / previewCanvas.width;
            const scaleFactorY = fullResCanvas.height / previewCanvas.height;
            
            // Draw scaled version to full resolution canvas
            fullResCtx.imageSmoothingEnabled = false; // Disable smoothing for pixel pattern
            fullResCtx.drawImage(
                previewCanvas,
                0, 0, previewCanvas.width, previewCanvas.height,
                0, 0, fullResCanvas.width, fullResCanvas.height
            );
            
            // Calculate physical dimensions for display
            const dpi = parseInt(canvasResolution.value);
            const width = parseInt(canvasWidthInput.value);
            const height = parseInt(canvasHeightInput.value);
            const widthUnit = canvasWidthUnit.value;
            const heightUnit = canvasHeightUnit.value;
            
            statusUpdate.textContent = `High resolution pattern generated: ${width}${widthUnit} √ó ${height}${heightUnit} at ${dpi} DPI`;
        } catch (error) {
            console.error("Error generating full resolution pattern:", error);
            statusUpdate.textContent = "Error generating high resolution pattern";
        }
    }
    // Download full resolution image
    function downloadFullResolution() {
        // Make sure we have a full resolution pattern
        if (animationState.rowsCompleted < animationState.totalRows) {
            // Not complete, generate full pattern first
            generateFullResolutionPattern();
        }
        
        // Create a temporary link element
        const link = document.createElement('a');
        
        // Generate a descriptive filename based on settings
        const scenario = climateScenarioSelect.value;
        const patternType = patternTypeSelect.value;
        const width = canvasWidthInput.value;
        const height = canvasHeightInput.value;
        const widthUnit = canvasWidthUnit.value;
        const heightUnit = canvasHeightUnit.value;
        const dpi = canvasResolution.value;
        
        const filename = `manila-clam-${patternType}-${scenario}-${width}${widthUnit}x${height}${heightUnit}-${dpi}dpi.png`;
        
        link.download = filename;
        
        // Convert canvas to data URL
        link.href = fullResCanvas.toDataURL('image/png');
        
        // Append to the document, click, and remove
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        statusUpdate.textContent = "High resolution pattern downloaded successfully";
    }

    // Get current environmental parameters (affected by events)
    function getCurrentEnvironmentalParams(row) {
        // Start with base parameters
        const params = {
            temperature: parseInt(temperatureInput.value),
            salinity: parseInt(salinityInput.value),
            sediment: parseInt(sedimentInput.value) / 100,
            acidification: parseInt(acidificationInput.value) / 100,
            microplastics: parseInt(microplasticsInput.value) / 100,
            seasonalVariation: parseInt(seasonalVariationInput.value) / 100
        };
        
        // Apply seasonal variation - UK-specific seasons
        const seasonalFrequency = 0.05; // Cycles per year
        const monthsElapsed = row * animationState.monthsPerRow;
        const yearsElapsed = monthsElapsed / 12;
        const seasonalPhase = Math.sin(yearsElapsed * 2 * Math.PI * seasonalFrequency);
        const seasonalEffect = seasonalPhase * params.seasonalVariation;
        
        // UK seasonal effect on temperature (warmer in summer, cooler in winter)
        params.temperature += seasonalEffect * 6; // UK seasonal temperature variation is less extreme
        
        // Apply environmental events
        for (const event of animationState.growthEvents) {
            if (row >= event.startRow && row <= event.endRow) {
                // Apply event effect
                const intensity = event.intensity * (1 - Math.abs((row - event.peakRow) / (event.endRow - event.startRow) * 2));
                
                if (event.type.includes('temperature')) {
                    // Temperature events - based on severity
                    if (event.type.includes('extreme')) {
                        params.temperature += intensity * 10; // Extreme heatwave
                    } else if (event.type.includes('mild')) {
                        params.temperature += intensity * 3; // Mild temperature change
                    } else {
                        params.temperature += intensity * 6; // Standard temperature event
                    }
                } else if (event.type.includes('salinity')) {
                    // Salinity events - based on severity
                    if (event.type.includes('extreme')) {
                        params.salinity -= intensity * 8; // Extreme freshwater input
                    } else if (event.type.includes('mild')) {
                        params.salinity -= intensity * 2; // Mild rainfall
                    } else {
                        params.salinity -= intensity * 5; // Standard salinity change
                    }
                } else if (event.type.includes('storm')) {
                    // Storm events affect both temperature and salinity
                    params.temperature -= intensity * 4;
                    params.salinity -= intensity * 6;
                } else if (event.type.includes('bloom')) {
                    // Algal bloom effects - changes growth patterns
                    if (event.type.includes('toxic')) {
                        params.acidification += intensity * 0.2;
                    }
                } else if (event.type === 'pollution') {
                    // Pollution events increase microplastics
                    params.microplastics += intensity * 0.3;
                } else if (event.type.includes('sediment')) {
                    // Sediment events
                    if (event.type.includes('extreme')) {
                        params.sediment += intensity * 0.7;
                    } else if (event.type.includes('heavy')) {
                        params.sediment += intensity * 0.5;
                    } else if (event.type.includes('mild')) {
                        params.sediment += intensity * 0.2;
                    } else {
                        params.sediment += intensity * 0.3;
                    }
                }
            }
        }
        
        // Apply acidification events
        for (const event of animationState.acidificationEvents) {
            if (row >= event.startRow && row <= event.endRow) {
                // Apply acidification event effect
                const intensity = event.intensity * (1 - Math.abs((row - event.peakRow) / (event.endRow - event.startRow) * 2));
                params.acidification += intensity * 0.5; // Increase acidification during event
            }
        }
        
        // Apply microplastic events
        for (const event of animationState.microplasticEvents) {
            if (row >= event.startRow && row <= event.endRow) {
                // Apply microplastic event effect
                const intensity = event.intensity * (1 - Math.abs((row - event.peakRow) / (event.endRow - event.startRow) * 2));
                params.microplastics += intensity * 0.5; // Increase microplastics during event
            }
        }
        
        // Apply sediment events
        for (const event of animationState.sedimentEvents) {
            if (row >= event.startRow && row <= event.endRow) {
                // Apply sediment event effect
                const intensity = event.intensity * (1 - Math.abs((row - event.peakRow) / (event.endRow - event.startRow) * 2));
                params.sediment += intensity * 0.5; // Increase sediment during event
            }
        }
        
        // Ensure values are within valid ranges for UK waters
        params.temperature = Math.max(5, Math.min(28, params.temperature));
        params.salinity = Math.max(25, Math.min(38, params.salinity));
        params.acidification = Math.max(0, Math.min(1, params.acidification));
        params.microplastics = Math.max(0, Math.min(1, params.microplastics));
        params.sediment = Math.max(0, Math.min(1, params.sediment));
        
        return params;
    }

    // Apply climate change effects to environmental parameters - UK specific
    function applyClimateChangeEffects(row, params) {
        const climateScenario = animationState.climateScenario;
        const totalRows = animationState.totalRows;
        const progress = row / totalRows; // Normalized growth progress (0-1)
        
        // Base parameters unchanged for pre-industrial
        if (climateScenario === 'pre-industrial') {
            return;
        }
        
        // Apply climate change effects based on scenario - UK specific
        switch (climateScenario) {
            case 'current':
                // Slight temperature increase over time - current UK trend
                params.temperature += progress * 1;
                
                // Slight acidification increase
                params.acidification += progress * 0.1;
                
                // Slight sediment increase due to land use changes
                params.sediment += progress * 0.05;
                break;
            
            case 'near-future':
                // Moderate temperature increase (1-2¬∞C) - UK 2050 projections
                params.temperature += progress * 3;
                
                // More acidification
                params.acidification += progress * 0.3;
                
                // More variability in seasonal effects
                params.seasonalVariation *= (1 + progress * 0.2);
                
                // More sediment from increased precipitation and erosion
                params.sediment += progress * 0.15;
                break;
            
            case 'worst-case':
                // Severe temperature increase (3-4¬∞C) - UK 2100 worst-case
                params.temperature += progress * 6;
                
                // Severe acidification
                params.acidification += progress * 0.5;
                
                // Extreme seasonal variability
                params.seasonalVariation *= (1 + progress * 0.4);
                
                // Extreme sediment from coastal erosion and flooding
                params.sediment += progress * 0.3;
                break;
        }
        
        // Ensure values are within valid ranges for UK waters
        params.temperature = Math.max(5, Math.min(28, params.temperature));
        params.acidification = Math.max(0, Math.min(1, params.acidification));
        params.seasonalVariation = Math.max(0, Math.min(1, params.seasonalVariation));
        params.sediment = Math.max(0, Math.min(1, params.sediment));
    }

    // Update growth info display
    function updateGrowthInfo(currentRow) {
        // Calculate age
        const currentAge = formatTimeDisplay(currentRow);
        
        // Basic info
        let infoHTML = `<h3>Growth Information</h3>`;
        
        if (currentRow === 0) {
            infoHTML += `<p>Ready to start growth simulation. Press the play button to begin.</p>`;
        } else {
            infoHTML += `<p>Current age: ${currentAge}</p>`;
            
            // Get current environmental conditions
            const currentParams = getCurrentEnvironmentalParams(currentRow);
            infoHTML += `<p>Current water temperature: ${currentParams.temperature.toFixed(1)}¬∞C</p>`;
            infoHTML += `<p>Current water salinity: ${currentParams.salinity.toFixed(1)} ppt</p>`;
            
            // Add sediment, acidification and microplastics
            infoHTML += `<p>Sediment concentration: ${(currentParams.sediment * 100).toFixed(1)}%</p>`;
            infoHTML += `<p>Acidification level: ${(currentParams.acidification * 100).toFixed(1)}%</p>`;
            infoHTML += `<p>Microplastic concentration: ${(currentParams.microplastics * 100).toFixed(1)}%</p>`;
            
            // Add climate scenario badge
            const climateScenario = animationState.climateScenario;
            infoHTML += `<p>Climate Scenario: <span class="climate-badge ${climateScenario}">${formatClimateScenario(climateScenario)}</span></p>`;
            
            // Add seasonal info - UK seasons
            const seasonValue = Math.sin(currentRow * 0.05) * currentParams.seasonalVariation;
            let season = "";
            if (seasonValue > 0.3) season = "Summer";
            else if (seasonValue < -0.3) season = "Winter";
            else if (seasonValue >= 0) season = "Spring";
            else season = "Autumn";
            
            infoHTML += `<p>Current season: ${season} in UK waters</p>`;
            
            // Add pattern blend info
            const { cellular, wave, growth, voronoi, radial } = animationState.patternBlend;
            infoHTML += `<p>Current pattern algorithm: 
                <span class="pattern-badge cellular">${Math.round(cellular * 100)}%</span>
                <span class="pattern-badge wave">${Math.round(wave * 100)}%</span>
                <span class="pattern-badge growth">${Math.round(growth * 100)}%</span>
                <span class="pattern-badge voronoi">${Math.round(voronoi * 100)}%</span>
                <span class="pattern-badge radial">${Math.round(radial * 100)}%</span>
            </p>`;
            
            // Check for active events
            const activeEvents = animationState.growthEvents.filter(
                event => currentRow >= event.startRow && currentRow <= event.endRow
            );
            
            const activeAcidificationEvents = animationState.acidificationEvents.filter(
                event => currentRow >= event.startRow && currentRow <= event.endRow
            );
            
            const activeMicroplasticEvents = animationState.microplasticEvents.filter(
                event => currentRow >= event.startRow && currentRow <= event.endRow
            );
            
            const activeSedimentEvents = animationState.sedimentEvents.filter(
                event => currentRow >= event.startRow && currentRow <= event.endRow
            );
            
            if (activeEvents.length > 0 || activeAcidificationEvents.length > 0 || 
                activeMicroplasticEvents.length > 0 || activeSedimentEvents.length > 0) {
                infoHTML += `<p>Active environmental events:</p>`;
                
                // Add growth events
                activeEvents.forEach(event => {
                    let eventClass = 'temperature';
                    if (event.type.includes('temperature')) eventClass = 'temperature';
                    else if (event.type.includes('salinity')) eventClass = 'salinity';
                    else if (event.type.includes('storm')) eventClass = 'seasonal';
                    else if (event.type.includes('bloom')) eventClass = 'seasonal';
                    else if (event.type.includes('pollution')) eventClass = 'microplastic';
                    else if (event.type.includes('sediment')) eventClass = 'sediment';
                    
                    infoHTML += `
                        <div class="growth-event ${eventClass}">
                            <div class="timestamp">${formatTimeDisplay(event.startRow)} - ${formatTimeDisplay(event.endRow)}</div>
                            <strong>${event.name}</strong>
                            <p>${event.description}</p>
                        </div>
                    `;
                });
                
                // Add acidification events
                activeAcidificationEvents.forEach(event => {
                    infoHTML += `
                        <div class="growth-event acidification">
                            <div class="timestamp">${formatTimeDisplay(event.startRow)} - ${formatTimeDisplay(event.endRow)}</div>
                            <strong>${event.name}</strong>
                            <p>${event.description}</p>
                        </div>
                    `;
                });
                
                // Add microplastic events
                activeMicroplasticEvents.forEach(event => {
                    infoHTML += `
                        <div class="growth-event microplastic">
                            <div class="timestamp">${formatTimeDisplay(event.startRow)} - ${formatTimeDisplay(event.endRow)}</div>
                            <strong>${event.name}</strong>
                            <p>${event.description}</p>
                        </div>
                    `;
                });
                
                // Add sediment events
                activeSedimentEvents.forEach(event => {
                    infoHTML += `
                        <div class="growth-event sediment">
                            <div class="timestamp">${formatTimeDisplay(event.startRow)} - ${formatTimeDisplay(event.endRow)}</div>
                            <strong>${event.name}</strong>
                            <p>${event.description}</p>
                        </div>
                    `;
                });
            }
        }
        
        // Update growth info
        growthInfo.innerHTML = infoHTML;
    }

    // Update environment graph
    function updateEnvironmentGraph(currentTime) {
        // Clear existing points
        temperatureLine.innerHTML = '';
        salinityLine.innerHTML = '';
        seasonalLine.innerHTML = '';
        microplasticLine.innerHTML = '';
        acidificationLine.innerHTML = '';
        sedimentLine.innerHTML = '';
        
        // Reset climate trend
        climateTrend.style.transform = 'none';
        
        // If no history, return
        if (animationState.environmentalHistory.length === 0) return;
        
        // Get max width
        const maxWidth = environmentGraph.clientWidth;
        
        // Get climate scenario for trend visualization
        const climateScenario = animationState.climateScenario;
      // Initialize trend slope
        let trendSlope = 0;
        
        // Set trend slope based on climate scenario - UK specific
        switch (climateScenario) {
            case 'pre-industrial':
                trendSlope = 0; // No trend
                climateTrend.style.opacity = '0';
                break;
            case 'current':
                trendSlope = 3; // Slight upward trend - UK current
                climateTrend.style.opacity = '0.3';
                break;
            case 'near-future':
                trendSlope = 10; // Moderate upward trend - UK 2050
                climateTrend.style.opacity = '0.5';
                break;
            case 'worst-case':
                trendSlope = 20; // Steep upward trend - UK 2100
                climateTrend.style.opacity = '0.7';
                break;
        }
        
        // Apply climate trend rotation if not pre-industrial
        if (climateScenario !== 'pre-industrial') {
            climateTrend.style.transform = `rotate(${-trendSlope}deg)`;
            climateTrend.style.transformOrigin = 'left center';
        }
        
        // Add points for each environmental factor
        animationState.environmentalHistory.forEach((data, index) => {
            // Calculate position
            const x = (data.row / animationState.totalRows) * maxWidth;
            
            // Temperature (normalized to 0-100%) - UK specific range
            const temperatureY = (1 - ((data.temperature - 5) / 23)) * 100; // 5-28¬∞C range
            const temperaturePoint = document.createElement('div');
            temperaturePoint.className = 'data-point temperature';
            temperaturePoint.style.left = `${x}px`;
            temperaturePoint.style.top = `${temperatureY}%`;
            temperatureLine.appendChild(temperaturePoint);
            
            // Salinity (normalized to 0-100%) - UK specific range
            const salinityY = (1 - ((data.salinity - 25) / 13)) * 100; // 25-38 ppt range
            const salinityPoint = document.createElement('div');
            salinityPoint.className = 'data-point salinity';
            salinityPoint.style.left = `${x}px`;
            salinityPoint.style.top = `${salinityY}%`;
            salinityLine.appendChild(salinityPoint);
            
            // Seasonal variation (already 0-1)
            const seasonalY = (1 - (Math.sin(data.row * 0.05) * data.seasonalVariation + 1) / 2) * 100;
            const seasonalPoint = document.createElement('div');
            seasonalPoint.className = 'data-point seasonal';
            seasonalPoint.style.left = `${x}px`;
            seasonalPoint.style.top = `${seasonalY}%`;
            seasonalLine.appendChild(seasonalPoint);
            
            // Microplastics (normalized to 0-100%)
            if (data.microplastics !== undefined) {
                const microplasticY = (1 - data.microplastics) * 100;
                const microplasticPoint = document.createElement('div');
                microplasticPoint.className = 'data-point microplastic';
                microplasticPoint.style.left = `${x}px`;
                microplasticPoint.style.top = `${microplasticY}%`;
                microplasticLine.appendChild(microplasticPoint);
            }
            
            // Acidification (normalized to 0-100%)
            if (data.acidification !== undefined) {
                const acidificationY = (1 - data.acidification) * 100;
                const acidificationPoint = document.createElement('div');
                acidificationPoint.className = 'data-point acidification';
                acidificationPoint.style.left = `${x}px`;
                acidificationPoint.style.top = `${acidificationY}%`;
                acidificationLine.appendChild(acidificationPoint);
            }
            
            // Sediment (normalized to 0-100%)
            if (data.sediment !== undefined) {
                const sedimentY = (1 - data.sediment) * 100;
                const sedimentPoint = document.createElement('div');
                sedimentPoint.className = 'data-point sediment';
                sedimentPoint.style.left = `${x}px`;
                sedimentPoint.style.top = `${sedimentY}%`;
                sedimentLine.appendChild(sedimentPoint);
            }
        });
        
        // Add current time marker if provided
        if (currentTime !== undefined) {
            const markerX = (currentTime / animationState.totalRows) * maxWidth;
            
            // Add marker
            const marker = document.createElement('div');
            marker.style.position = 'absolute';
            marker.style.left = `${markerX}px`;
            marker.style.top = '0';
            marker.style.height = '100%';
            marker.style.width = '1px';
            marker.style.backgroundColor = 'red';
            marker.style.zIndex = '10';
            environmentGraph.appendChild(marker);
            
            // Remove after a short delay (to prevent accumulation)
            setTimeout(() => {
                if (marker.parentNode) {
                    marker.parentNode.removeChild(marker);
                }
            }, 100);
        }
    }

    // Create age bands
    function createAgeBands() {
        // Clear existing bands
        ageBands.innerHTML = '';
        
        // Calculate number of years
        const years = animationState.growthYears;
        
        // Create a band for each year
        for (let i = 0; i < years; i++) {
            const band = document.createElement('div');
            band.className = 'age-band';
            band.style.backgroundColor = `hsl(${200 + (i * 15)}, 70%, ${90 - (i * 5)}%)`;
            ageBands.appendChild(band);
        }
    }

    // Update age bands based on current growth
    function updateAgeBands(currentRow) {
        // Calculate current progress
        const progress = currentRow / animationState.totalRows;
        
        // Update each band
        const bands = ageBands.querySelectorAll('.age-band');
        bands.forEach((band, index) => {
            const bandStart = index / bands.length;
            const bandEnd = (index + 1) / bands.length;
            
            if (progress >= bandEnd) {
                // This band is complete
                band.style.opacity = 1;
            } else if (progress >= bandStart) {
                // This band is in progress
                const bandProgress = (progress - bandStart) / (bandEnd - bandStart);
                band.style.opacity = bandProgress;
            } else {
                // This band has not started
                band.style.opacity = 0.2;
            }
        });
    }

    // Utility functions
    function hexToRgb(hex) {
        // Remove # if present
        hex = hex.replace('#', '');
        
        // Parse hex values
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        return { r, g, b };
    }

    // Linear interpolation function
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    // Simple 1D Simplex noise implementation for pattern generation
    function simplex1D(size, scale) {
        const noise = new Array(size);
        
        for (let i = 0; i < size; i++) {
            noise[i] = Math.sin(i * scale) * 0.5 + Math.sin(i * scale * 0.631) * 0.35 + Math.sin(i * scale * 1.754) * 0.15;
        }
        
        return noise;
    }

    // Perlin noise implementation (simplified)
    function perlinNoise(x, y) {
        // Simplified Perlin noise function
        return Math.sin(x * 10) * Math.cos(y * 10) * 0.5 + 
                Math.sin(x * 20 + 5) * Math.cos(y * 20 + 3) * 0.25 + 
                Math.sin(x * 40 + 13) * Math.cos(y * 40 + 7) * 0.125;
    }

    // Pattern generation variables
    let cellStates, temperatureNoise, salinityNoise, waveSources, baseColor, accentColor, microplasticColor, sedimentColor;
    let voronoiSites, voronoiCells, radialCenters;
    let environmentParams = {};

    // Initialize pattern generation
    function initializePatternGeneration() {
        const width = previewCanvas.width;
        const complexity = parseInt(complexityInput.value);
        const temperature = parseInt(temperatureInput.value);
        const salinity = parseInt(salinityInput.value);
        const sediment = parseInt(sedimentInput.value) / 100;
        const acidification = parseInt(acidificationInput.value) / 100;
        const microplastics = parseInt(microplasticsInput.value) / 100;
        
        // Store initial environmental parameters
        environmentParams = {
            temperature: temperature,
            salinity: salinity,
            sediment: sediment,
            acidification: acidification,
            microplastics: microplastics,
            seasonalVariation: parseInt(seasonalVariationInput.value) / 100
        };
        
        // Parse colors
        baseColor = hexToRgb(baseColorInput.value);
        accentColor = hexToRgb(accentColorInput.value);
        microplasticColor = hexToRgb(microplasticColorInput.value);
        sedimentColor = hexToRgb(sedimentColorInput.value);
        
        // Initialize cellular automaton pattern
        initializeCellularPattern(width, complexity, temperature, salinity);
        
        // Initialize wave interference pattern
        initializeWavePattern(width, complexity, temperature, salinity);
        
        // Initialize Voronoi pattern
        initializeVoronoiPattern(width, complexity);
        
        // Initialize Radial pattern
        initializeRadialPattern(width, complexity);
        
        // Growth ring pattern doesn't need specific initialization
    }

    // Initialize cellular automaton pattern
    function initializeCellularPattern(width, complexity, temperature, salinity) {
        // Rule number for cellular automaton
        const rule = Math.floor(complexity / 10) + 30;
        
        // Initialize cell states
        cellStates = new Array(width).fill(0);
        
        // Create noise values for environmental factors
        temperatureNoise = simplex1D(width, temperature / 100);
        salinityNoise = simplex1D(width, salinity / 50);
        
        // Cell density affected by salinity
        const cellDensity = 0.3 + (salinity / 100);
        
        // Initialize with some random cells
        for (let x = 0; x < width; x++) {
            if (Math.random() < cellDensity) {
                cellStates[x] = 1;
            }
        }
    }

    // Initialize wave interference pattern
    function initializeWavePattern(width, complexity, temperature, salinity) {
        // Wave parameters based on input settings
        const waveCount = 3 + Math.floor(complexity / 20); // Number of wave sources
        waveSources = [];
        
        // Create wave sources
        for (let i = 0; i < waveCount; i++) {
            waveSources.push({
                x: Math.random() * width,
                y: Math.random() * previewCanvas.height,
                frequency: 0.01 + (Math.random() * 0.02),
                amplitude: 0.5 + (Math.random() * 0.5),
                phase: Math.random() * Math.PI * 2
            });
        }
    }

    // Initialize Voronoi pattern
    function initializeVoronoiPattern(width, complexity) {
        // Number of sites based on complexity
        const siteCount = 5 + Math.floor(complexity / 10);
        voronoiSites = [];
        
        // Create Voronoi sites
        for (let i = 0; i < siteCount; i++) {
            voronoiSites.push({
                x: Math.random() * width,
                y: Math.random() * previewCanvas.height,
                intensity: 0.5 + (Math.random() * 0.5)
            });
        }
    }

    // Initialize Radial pattern - moved to top edge
    function initializeRadialPattern(width, complexity) {
        // Number of radial centers based on complexity
        const centerCount = 1 + Math.floor(complexity / 25);
        radialCenters = [];
        
        // Create radial centers along the top edge
        for (let i = 0; i < centerCount; i++) {
            // Position centers along the top edge with some variation
            // Note: y=0 is the top edge of the canvas
            radialCenters.push({
                x: width * (0.2 + Math.random() * 0.6), // Spread across top edge with some inset
                y: previewCanvas.height * 0.05, // Slightly below top edge for better visibility
                radius: width * (0.3 + Math.random() * 0.3),
                // Add noise to the number of spokes that radiate from each center
                // Higher complexity = more base spokes
                spokeCount: 5 + Math.floor(complexity / 10) + Math.floor(Math.random() * 5),
                spokeNoise: 0.2 + (Math.random() * 0.5), // Amount of noise/irregularity in spoke distribution
                ringDensity: 5 + Math.random() * (complexity / 10),
                radiationOffset: Math.random() * Math.PI
            });
        }
    }

    // Draw next row of the pattern
    function drawNextRow() {
        if (animationState.currentRow >= animationState.totalRows) {
            return;
        }
        
        const width = previewCanvas.width;
        const y = animationState.currentRow;
        
        // Get current environmental parameters (may be modified by events)
        const rowParams = getCurrentEnvironmentalParams(y);
        
        // Create array for this row's pixel data
        const rowData = new Uint8ClampedArray(width * 4);
        
        // Apply climate change effects to environmental parameters
        applyClimateChangeEffects(y, rowParams);
        
        // Generate row with blended pattern algorithms
        generateBlendedPatternRow(rowData, width, y, rowParams);
        
        // Draw the row on the canvas
        const imageData = new ImageData(rowData, width, 1);
        previewCtx.putImageData(imageData, 0, y);
        
        // Store environmental data for this row
        animationState.environmentalHistory.push({
            row: y,
            temperature: rowParams.temperature,
            salinity: rowParams.salinity,
            sediment: rowParams.sediment,
            acidification: rowParams.acidification,
            microplastics: rowParams.microplastics,
            seasonalVariation: rowParams.seasonalVariation
        });
        
        // Increment current row
        animationState.currentRow++;
        animationState.rowsCompleted = animationState.currentRow;
    }

    // Generate blended pattern row using current pattern blend weights
    function generateBlendedPatternRow(rowData, width, y, params) {
        // Get current pattern blend weights
        const { cellular, wave, growth, voronoi, radial } = animationState.patternBlend;
        
        // Get symmetry factor
        const symmetryFactor = animationState.symmetryFactor;
        
        // If one pattern has 100% weight, use that pattern directly
        if (cellular === 1) {
            generateCellularRow(rowData, width, y, params, symmetryFactor);
            return;
        }
        if (wave === 1) {
            generateWaveRow(rowData, width, y, params, symmetryFactor);
            return;
        }
        if (growth === 1) {
            generateGrowthRow(rowData, width, y, params, symmetryFactor);
            return;
        }
        if (voronoi === 1) {
            generateVoronoiRow(rowData, width, y, params, symmetryFactor);
            return;
        }
        if (radial === 1) {
            generateRadialRow(rowData, width, y, params, symmetryFactor);
            return;
        }
        
        // Create temporary arrays for each pattern type
        const cellularData = new Uint8ClampedArray(width * 4);
        const waveData = new Uint8ClampedArray(width * 4);
        const growthData = new Uint8ClampedArray(width * 4);
        const voronoiData = new Uint8ClampedArray(width * 4);
        const radialData = new Uint8ClampedArray(width * 4);
        
        // Generate each pattern type
        if (cellular > 0) {
            generateCellularRow(cellularData, width, y, params, symmetryFactor);
        }
        if (wave > 0) {
            generateWaveRow(waveData, width, y, params, symmetryFactor);
        }
        if (growth > 0) {
            generateGrowthRow(growthData, width, y, params, symmetryFactor);
        }
        if (voronoi > 0) {
            generateVoronoiRow(voronoiData, width, y, params, symmetryFactor);
        }
        if (radial > 0) {
            generateRadialRow(radialData, width, y, params, symmetryFactor);
        }
        
        // Blend patterns based on weights
        for (let x = 0; x < width; x++) {
            const pixelIndex = x * 4;
            
            // Weighted average of R, G, B values from each pattern
            for (let c = 0; c < 3; c++) {
                rowData[pixelIndex + c] = Math.round(
                    (cellularData[pixelIndex + c] * cellular) +
                    (waveData[pixelIndex + c] * wave) +
                    (growthData[pixelIndex + c] * growth) +
                    (voronoiData[pixelIndex + c] * voronoi) +
                    (radialData[pixelIndex + c] * radial)
                );
            }
            
            // Alpha is always 255 (opaque)
            rowData[pixelIndex + 3] = 255;
        }
        
        // Add microplastic particles
        addMicroplasticParticles(rowData, width, y, params);
        
        // Apply sediment effects
        applySedimentEffects(rowData, width, y, params);
        
        // Apply acidification effects
        applyAcidificationEffects(rowData, width, y, params);
    }

    // Add microplastic particles to the pattern
    function addMicroplasticParticles(rowData, width, y, params) {
        const microplasticLevel = params.microplastics;
        
        // Skip if no microplastics
        if (microplasticLevel <= 0) {
            return;
        }
        
        // Number of potential microplastic particles in this row
        const particleCount = Math.floor(width * microplasticLevel * 0.1);
        
        // Add particles randomly
        for (let i = 0; i < particleCount; i++) {
            // Random position in the row
            const x = Math.floor(Math.random() * width);
            const pixelIndex = x * 4;
            
            // Only add particles with some probability
            if (Math.random() < microplasticLevel) {
                // Microplastic color with some variation
                const r = microplasticColor.r + Math.floor((Math.random() - 0.5) * 20);
                const g = microplasticColor.g + Math.floor((Math.random() - 0.5) * 20);
                const b = microplasticColor.b + Math.floor((Math.random() - 0.5) * 20);
                
                // Set pixel color
                rowData[pixelIndex] = r;
                rowData[pixelIndex + 1] = g;
                rowData[pixelIndex + 2] = b;
            }
        }
    }

    // Apply sediment effects to the pattern
    function applySedimentEffects(rowData, width, y, params) {
        const sedimentLevel = params.sediment;
        
        // Skip if no sediment
        if (sedimentLevel <= 0) {
            return;
        }
        
        // Determine density of sediment effects
        const effectDensity = sedimentLevel * 0.7;
        
        // Apply sediment texture effects across the row
        for (let x = 0; x < width; x++) {
            // Apply effect with varying intensity based on Perlin noise
            const noiseValue = perlinNoise(x * 0.05, y * 0.05) * 0.5 + 0.5;
            const localEffect = sedimentLevel * noiseValue;
            
            // Skip some pixels randomly to create uneven texture
            if (Math.random() < localEffect * effectDensity) {
                const pixelIndex = x * 4;
                
                // Blend with sediment color
                const blendFactor = localEffect * 0.5; // How much sediment color to blend in
                
                // Original color
                const origR = rowData[pixelIndex];
                const origG = rowData[pixelIndex + 1];
                const origB = rowData[pixelIndex + 2];
                
                // Blend with sediment color
                rowData[pixelIndex] = Math.round(lerp(origR, sedimentColor.r, blendFactor));
                rowData[pixelIndex + 1] = Math.round(lerp(origG, sedimentColor.g, blendFactor));
                rowData[pixelIndex + 2] = Math.round(lerp(origB, sedimentColor.b, blendFactor));
            }
        }
        
        // Create sediment texture clusters
        if (sedimentLevel > 0.3 && Math.random() < sedimentLevel * 0.4) {
            const clusterStart = Math.floor(Math.random() * (width - 20));
            const clusterSize = Math.floor(5 + Math.random() * 15 * sedimentLevel);
            
            for (let i = 0; i < clusterSize; i++) {
                const x = clusterStart + Math.floor(Math.random() * clusterSize);
                
                if (x >= 0 && x < width) {
                    const pixelIndex = x * 4;
                    const blendFactor = 0.3 + Math.random() * 0.4;
                    
                    // Apply stronger sediment effect in clusters
                    rowData[pixelIndex] = Math.round(lerp(rowData[pixelIndex], sedimentColor.r, blendFactor));
                    rowData[pixelIndex + 1] = Math.round(lerp(rowData[pixelIndex + 1], sedimentColor.g, blendFactor));
                    rowData[pixelIndex + 2] = Math.round(lerp(rowData[pixelIndex + 2], sedimentColor.b, blendFactor));
                }
            }
        }
    }

    // Apply acidification effects to the pattern
    function applyAcidificationEffects(rowData, width, y, params) {
        const acidificationLevel = params.acidification;
        
        // Skip if no acidification
        if (acidificationLevel <= 0) {
            return;
        }
        
        // Color fading effect - represents calcium carbonate dissolution
        for (let x = 0; x < width; x++) {
            // Apply effect with varying intensity across the row
            const localEffect = acidificationLevel * (0.5 + Math.sin(x * 0.01) * 0.5);
            
            // Skip some pixels randomly to create uneven effect
            if (Math.random() < localEffect * 0.7) {
                const pixelIndex = x * 4;
                
                // Fade color toward lighter, more translucent shade
                rowData[pixelIndex] = Math.min(255, rowData[pixelIndex] + Math.floor(localEffect * 40));
                rowData[pixelIndex + 1] = Math.min(255, rowData[pixelIndex + 1] + Math.floor(localEffect * 40));
                rowData[pixelIndex + 2] = Math.min(255, rowData[pixelIndex + 2] + Math.floor(localEffect * 40));
            }
        }
        
        // Pattern disruptions - create occasional gaps or distortions
        if (Math.random() < acidificationLevel * 0.3) {
            const disruptionStart = Math.floor(Math.random() * width * 0.7);
            const disruptionWidth = Math.floor(5 + Math.random() * 20 * acidificationLevel);
            
            for (let x = disruptionStart; x < disruptionStart + disruptionWidth && x < width; x++) {
                const pixelIndex = x * 4;
                
                // Create whitish disruption
                rowData[pixelIndex] = Math.min(255, rowData[pixelIndex] + 80);
                rowData[pixelIndex + 1] = Math.min(255, rowData[pixelIndex + 1] + 80);
                rowData[pixelIndex + 2] = Math.min(255, rowData[pixelIndex + 2] + 80);
            }
        }
    }
    // Generate cellular automaton pattern row
    function generateCellularRow(rowData, width, y, params, symmetryFactor) {
        const {
            temperature,
            salinity,
            sediment,
            seasonalVariation
        } = params;
        
        const colorVariation = parseInt(colorVariationInput.value) / 100;
        const rule = Math.floor(parseInt(complexityInput.value) / 10) + 30;
        
        // Seasonal effect - varies with position
        const seasonalFrequency = 0.1 + (seasonalVariation * 0.2);
        const seasonalEffect = Math.sin(y * seasonalFrequency) * seasonalVariation;
        
        // Apply the cellular automaton rule to generate the next row
        const newStates = new Array(width).fill(0);
        
        for (let x = 0; x < width; x++) {
            // Apply bilateral symmetry if enabled
            const symmetryX = applySymmetry(x, width, symmetryFactor);
            
            // Get the current cell and its neighbors
            const left = symmetryX > 0 ? cellStates[symmetryX - 1] : cellStates[width - 1];
            const center = cellStates[symmetryX];
            const right = symmetryX < width - 1 ? cellStates[symmetryX + 1] : cellStates[0];
            
            // Calculate the rule index
            const index = (left << 2) | (center << 1) | right;
            
            // Apply the rule
            const bit = (rule >> index) & 1;
            
            // Environmental factors influence the cell state
            const tempEffect = temperatureNoise[symmetryX] * (temperature / 35); // Temperature effect
            const salEffect = salinityNoise[symmetryX] * (salinity / 40);       // Salinity effect
            
            // Sediment effect - can disrupt pattern regularity
            const sedimentEffect = perlinNoise(symmetryX * 0.05, y * 0.05) * sediment;
            
            // Combined environmental effect
            const environmentalEffect = tempEffect + salEffect + seasonalEffect + sedimentEffect;
            
            // Apply environmental effect with some randomness
            if (Math.random() < Math.abs(environmentalEffect) * 0.3) {
                newStates[symmetryX] = bit === 0 ? 1 : 0; // Flip the bit sometimes
            } else {
                newStates[symmetryX] = bit;
            }
            
            // Calculate color based on cell state and environmental factors
            let r, g, b;
            
            if (newStates[symmetryX] === 1) {
                // Mix between base and accent color based on environmental factors
                const mixRatio = 0.3 + (Math.abs(environmentalEffect) * 0.7);
                
                // Add some randomness to colors for natural variation
                const randomVariation = (Math.random() - 0.5) * colorVariation * 50;
                
                r = Math.floor(lerp(baseColor.r, accentColor.r, mixRatio) + randomVariation);
                g = Math.floor(lerp(baseColor.g, accentColor.g, mixRatio) + randomVariation);
                b = Math.floor(lerp(baseColor.b, accentColor.b, mixRatio) + randomVariation);
                
                // Apply sediment effect to color
                if (sediment > 0.2) {
                    const sedimentInfluence = sediment * 0.5;
                    r = Math.floor(lerp(r, sedimentColor.r, sedimentInfluence));
                    g = Math.floor(lerp(g, sedimentColor.g, sedimentInfluence));
                    b = Math.floor(lerp(b, sedimentColor.b, sedimentInfluence));
                }
            } else {
                // Base color with slight variations
                const randomVariation = (Math.random() - 0.5) * colorVariation * 30;
                
                r = Math.floor(baseColor.r + randomVariation);
                g = Math.floor(baseColor.g + randomVariation);
                b = Math.floor(baseColor.b + randomVariation);
                
                // Subtle sediment effect on base color
                if (sediment > 0.3 && Math.random() < sediment * 0.2) {
                    const sedimentInfluence = sediment * 0.3;
                    r = Math.floor(lerp(r, sedimentColor.r, sedimentInfluence));
                    g = Math.floor(lerp(g, sedimentColor.g, sedimentInfluence));
                    b = Math.floor(lerp(b, sedimentColor.b, sedimentInfluence));
                }
            }
            
            // Clamp RGB values to valid range
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // Set pixel color
            const pixelIndex = x * 4;
            rowData[pixelIndex] = r;
            rowData[pixelIndex + 1] = g;
            rowData[pixelIndex + 2] = b;
            rowData[pixelIndex + 3] = 255; // Fully opaque
        }
        
        // Update states for next row
        cellStates = newStates;
    }

    // Generate wave interference pattern row
    function generateWaveRow(rowData, width, y, params, symmetryFactor) {
        const {
            temperature,
            salinity,
            sediment,
            seasonalVariation
        } = params;
        
        const colorVariation = parseInt(colorVariationInput.value) / 100;
        
        // Temperature affects wave speed/frequency
        const tempFactor = temperature / 20;
        
        // Salinity affects wave amplitude
        const salinityFactor = salinity / 30;
        
        // Sediment affects pattern clarity
        const sedimentFactor = 1.0 - (sediment * 0.5);
        
        // Seasonal effect - varies with position
        const seasonalPhase = Math.sin(y * 0.01) * seasonalVariation * Math.PI;
        
        for (let x = 0; x < width; x++) {
            // Apply bilateral symmetry if enabled
            const symmetryX = applySymmetry(x, width, symmetryFactor);
            
            // Calculate combined wave effect at this point
            let waveValue = 0;
            
            for (const source of waveSources) {
                const dx = symmetryX - source.x;
                const dy = y - source.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Wave equation with environmental factors
                const angle = distance * source.frequency * tempFactor + source.phase + seasonalPhase;
                const value = Math.sin(angle) * source.amplitude * salinityFactor;
                
                waveValue += value;
            }
            
            // Normalize wave value to 0-1 range
            waveValue = (waveValue + waveSources.length) / (waveSources.length * 2);
            
            // Add noise for texture - increased with sediment
            const noiseAmount = colorVariation + (sediment * 0.3);
            const noiseValue = perlinNoise(symmetryX * 0.05, y * 0.05) * noiseAmount;
            
            // Apply sediment effect to reduce pattern clarity
            waveValue = waveValue * sedimentFactor + noiseValue;
            waveValue = Math.max(0, Math.min(1, waveValue));
            
            // Interpolate between base and accent color
            let r = Math.floor(lerp(baseColor.r, accentColor.r, waveValue));
            let g = Math.floor(lerp(baseColor.g, accentColor.g, waveValue));
            let b = Math.floor(lerp(baseColor.b, accentColor.b, waveValue));
            
            // Apply sediment color at high sediment levels
            if (sediment > 0.4 && Math.random() < sediment * 0.3) {
                const sedimentInfluence = sediment * 0.4;
                r = Math.floor(lerp(r, sedimentColor.r, sedimentInfluence));
                g = Math.floor(lerp(g, sedimentColor.g, sedimentInfluence));
                b = Math.floor(lerp(b, sedimentColor.b, sedimentInfluence));
            }
            
            // Clamp RGB values
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // Set pixel color
            const pixelIndex = x * 4;
            rowData[pixelIndex] = r;
            rowData[pixelIndex + 1] = g;
            rowData[pixelIndex + 2] = b;
            rowData[pixelIndex + 3] = 255; // Fully opaque
        }
    }

    // Generate growth ring pattern row
    function generateGrowthRow(rowData, width, y, params, symmetryFactor) {
        const {
            temperature,
            salinity,
            sediment,
            seasonalVariation
        } = params;
        
        const complexity = parseInt(complexityInput.value);
        const colorVariation = parseInt(colorVariationInput.value) / 100;
        
        // Center of the shell (growth origin)
        const centerX = width / 2;
        const centerY = previewCanvas.height / 2;
        
        // Growth parameters
        const growthRate = 0.5 + (temperature / 35); // Higher temperature, faster growth
        const growthVariation = 0.1 + (complexity / 100);
        const ringDensity = 5 + (complexity / 10);
        
        // Salinity affects pattern definition
        const patternDefinition = 0.5 + (salinity / 40);
        
        // Sediment affects texture and clarity
        const sedimentEffect = sediment * 0.5;
        
        // Seasonal effect - varies with vertical position
        const seasonalEffect = Math.sin(y * 0.1) * seasonalVariation;
        
        for (let x = 0; x < width; x++) {
            // Apply bilateral symmetry if enabled
            const symmetryX = applySymmetry(x, width, symmetryFactor);
            
            // Calculate distance from center (normalized)
            const dx = (symmetryX - centerX) / width;
            const dy = (y - centerY) / previewCanvas.height;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate angle from center
            const angle = Math.atan2(dy, dx);
            
            // Growth rings - vary with distance
            const ring = Math.sin(distance * ringDensity * Math.PI * 2);
            
            // Add radial variation based on angle
            const radialVariation = Math.sin(angle * 5) * growthVariation;
            
            // Add sediment texture noise
            const textureNoise = sediment > 0.2 ? 
                perlinNoise(symmetryX * 0.02, y * 0.02) * sedimentEffect : 0;
            
            // Add general noise for texture
            const generalNoise = perlinNoise(symmetryX * 0.01, y * 0.01) * 0.5;
            
            // Combined pattern value
            let patternValue = (ring + radialVariation + seasonalEffect + generalNoise + textureNoise) * patternDefinition;
            patternValue = (patternValue + 1) / 2; // Normalize to 0-1
            
            // Add growth rate effect
            patternValue *= (1 - Math.pow(distance, growthRate));
            
            // Add color variation
            const colorNoise = (Math.random() - 0.5) * colorVariation;
            patternValue = Math.max(0, Math.min(1, patternValue + colorNoise));
            
            // Interpolate between base and accent color
            let r = Math.floor(lerp(baseColor.r, accentColor.r, patternValue));
            let g = Math.floor(lerp(baseColor.g, accentColor.g, patternValue));
            let b = Math.floor(lerp(baseColor.b, accentColor.b, patternValue));
            
            // Apply sediment color influence at higher sediment levels
            if (sediment > 0.3 && Math.random() < sediment * 0.4) {
                const sedimentInfluence = sediment * 0.3;
                r = Math.floor(lerp(r, sedimentColor.r, sedimentInfluence));
                g = Math.floor(lerp(g, sedimentColor.g, sedimentInfluence));
                b = Math.floor(lerp(b, sedimentColor.b, sedimentInfluence));
            }
            
            // Clamp RGB values
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // Set pixel color
            const pixelIndex = x * 4;
            rowData[pixelIndex] = r;
            rowData[pixelIndex + 1] = g;
            rowData[pixelIndex + 2] = b;
            rowData[pixelIndex + 3] = 255; // Fully opaque
        }
    }

    // Generate Voronoi pattern row
    function generateVoronoiRow(rowData, width, y, params, symmetryFactor) {
        const {
            temperature,
            salinity,
            sediment,
            acidification
        } = params;
        
        const complexity = parseInt(complexityInput.value);
        const colorVariation = parseInt(colorVariationInput.value) / 100;
        
        // Apply environmental factors to pattern
        const tempInfluence = 0.5 + (temperature / 40); // Cell size variation
        const salinityInfluence = 1.0 - (salinity / 80); // Edge sharpness
        
        // Sediment effect on pattern definition
        const sedimentInfluence = 1.0 - (sediment * 0.5); // More sediment = less defined edges
        
        for (let x = 0; x < width; x++) {
            // Apply bilateral symmetry if enabled
            const symmetryX = applySymmetry(x, width, symmetryFactor);
            
            // Find closest Voronoi site
            let minDist = Number.MAX_VALUE;
            let secondMinDist = Number.MAX_VALUE;
            let closestSite = null;
            
            for (const site of voronoiSites) {
                // Distance calculation with temperature influence on cell size
                const dx = (site.x - symmetryX) * tempInfluence;
                const dy = (site.y - y) * tempInfluence;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < minDist) {
                    secondMinDist = minDist;
                    minDist = dist;
                    closestSite = site;
                } else if (dist < secondMinDist) {
                    secondMinDist = dist;
                }
            }
            
            // Calculate edge factor (0 = center of cell, 1 = edge)
            // Salinity and sediment influence affect edge sharpness
            const combinedInfluence = salinityInfluence * sedimentInfluence;
            const edgeFactor = Math.pow(1.0 - (minDist / secondMinDist), 1.5 + combinedInfluence);
            
            // Add sediment texture noise
            const sedimentNoise = sediment > 0.2 ? 
                perlinNoise(symmetryX * 0.03, y * 0.03) * (sediment * 0.5) : 0;
            
            // Perturb with some general noise for more natural look
            const generalNoise = perlinNoise(symmetryX * 0.02, y * 0.02) * 0.3;
            
            // Pattern intensity based on cell and environmental factors
            let patternValue = Math.max(0, Math.min(1, edgeFactor + generalNoise + sedimentNoise));
            
            // Acid effect creates gaps in pattern
            if (acidification > 0.2 && Math.random() < acidification * 0.3 && patternValue > 0.5) {
                patternValue *= (1 - acidification * 0.5);
            }
            
            // Add color variation
            const colorNoise = (Math.random() - 0.5) * colorVariation;
            patternValue = Math.max(0, Math.min(1, patternValue + colorNoise));
            
            // Interpolate between base and accent color
            let r = Math.floor(lerp(baseColor.r, accentColor.r, patternValue));
            let g = Math.floor(lerp(baseColor.g, accentColor.g, patternValue));
            let b = Math.floor(lerp(baseColor.b, accentColor.b, patternValue));
            
            // Apply sediment color at higher sediment levels
            if (sediment > 0.4 && Math.random() < sediment * 0.3) {
                const sedimentInfluence = sediment * 0.3;
                r = Math.floor(lerp(r, sedimentColor.r, sedimentInfluence));
                g = Math.floor(lerp(g, sedimentColor.g, sedimentInfluence));
                b = Math.floor(lerp(b, sedimentColor.b, sedimentInfluence));
            }
            
            // Clamp RGB values
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // Set pixel color
            const pixelIndex = x * 4;
            rowData[pixelIndex] = r;
            rowData[pixelIndex + 1] = g;
            rowData[pixelIndex + 2] = b;
            rowData[pixelIndex + 3] = 255; // Fully opaque
        }
    }

    // Generate Radial pattern row - from top edge with variable spoke count
    function generateRadialRow(rowData, width, y, params, symmetryFactor) {
        const {
            temperature,
            salinity,
            sediment,
            acidification,
            seasonalVariation
        } = params;
        
        const complexity = parseInt(complexityInput.value);
        const colorVariation = parseInt(colorVariationInput.value) / 100;
        
        // Environmental influences
        const temperatureInfluence = temperature / 20; // Growth speed
        const salinityInfluence = salinity / 35; // Pattern clarity
        const sedimentInfluence = 1.0 - (sediment * 0.4); // Sediment reduces pattern clarity
        const seasonalPhase = Math.sin(y * 0.05) * seasonalVariation;
        
        for (let x = 0; x < width; x++) {
            // Apply bilateral symmetry if enabled
            const symmetryX = applySymmetry(x, width, symmetryFactor);
            
            // Initialize pattern value
            let patternValue = 0;
            let contributingCenters = 0;
            
            // Iterate through each radial center
            for (const center of radialCenters) {
                // Calculate distance from this center
                const dx = symmetryX - center.x;
                const dy = y - center.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Skip if too far from this center
                if (dist > center.radius * 1.5) continue;
                
                // Calculate normalized distance
                const normDist = dist / center.radius;
                
                // Calculate angle from center
                const angle = Math.atan2(dy, dx);
                
                // Apply noise to the number of radial spokes using the center's spokeNoise value
                // Higher noise = more irregular spoke pattern
                const noisedSpokeCount = center.spokeCount * (1 + perlinNoise(angle * 2, normDist) * center.spokeNoise);
                
                // Base radial pattern
                // 1. Radial lines emanating from center (top edge)
                const radialLines = Math.abs(Math.sin(angle * noisedSpokeCount + center.radiationOffset));
                
                // 2. Growth rings based on distance from center
                const growthRings = Math.sin(normDist * center.ringDensity * Math.PI * temperatureInfluence + seasonalPhase);
                
                // 3. Color variations based on angle sectors
                const sectorVariation = Math.cos(angle * 3 + normDist * 5) * 0.3;
                
                // Combine patterns with environmental influence
                let centerPattern = (
                    (radialLines * 0.5) +
                    (growthRings * 0.3) +
                    (sectorVariation * 0.2)
                ) * salinityInfluence * sedimentInfluence;
                
                // Apply distance falloff
                const falloff = Math.max(0, 1 - Math.pow(normDist / 1.0, 2));
                centerPattern *= falloff;
                
                // Add to total pattern value, weighted by falloff
                patternValue += centerPattern * falloff;
                contributingCenters += falloff;
            }
            
            // Normalize pattern value if we have contributions
            if (contributingCenters > 0) {
                patternValue /= contributingCenters;
            }
            
            // Normalize to 0-1
            patternValue = (patternValue + 1) / 2;
            
            // Add noise for organic texture
            const generalNoise = perlinNoise(symmetryX * 0.03, y * 0.03) * 0.2;
            
            // Add sediment texture if significant
            const sedimentNoise = sediment > 0.3 ? 
                perlinNoise(symmetryX * 0.05, y * 0.05) * (sediment * 0.4) : 0;
            
            patternValue = Math.max(0, Math.min(1, patternValue + generalNoise + sedimentNoise));
            
            // Apply acidification effect - create patchy thin areas
            if (acidification > 0.3 && patternValue > 0.5 && Math.random() < acidification * 0.4) {
                patternValue *= (1 - acidification * 0.6);
            }
            
            // Add random color variation
            const randomVariation = (Math.random() - 0.5) * colorVariation * 0.4;
            patternValue = Math.max(0, Math.min(1, patternValue + randomVariation));
            
            // Interpolate between base and accent color
            let r = Math.floor(lerp(baseColor.r, accentColor.r, patternValue));
            let g = Math.floor(lerp(baseColor.g, accentColor.g, patternValue));
            let b = Math.floor(lerp(baseColor.b, accentColor.b, patternValue));
            
            // Apply sediment color at higher sediment levels
            if (sediment > 0.4 && Math.random() < sediment * 0.3) {
                const sedimentInfluence = sediment * 0.3;
                r = Math.floor(lerp(r, sedimentColor.r, sedimentInfluence));
                g = Math.floor(lerp(g, sedimentColor.g, sedimentInfluence));
                b = Math.floor(lerp(b, sedimentColor.b, sedimentInfluence));
            }
            
            // Clamp RGB values
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // Set pixel color
            const pixelIndex = x * 4;
            rowData[pixelIndex] = r;
            rowData[pixelIndex + 1] = g;
            rowData[pixelIndex + 2] = b;
            rowData[pixelIndex + 3] = 255; // Fully opaque
        }
    }

    // Apply bilateral symmetry to x coordinate
    function applySymmetry(x, width, symmetryFactor) {
        // If symmetry is disabled or minimal, return original x
        if (symmetryFactor < 0.1) return x;
        
        const centerX = width / 2;
        const distFromCenter = x - centerX;
        
        // If point is on center or symmetry is full, use symmetric position
        if (distFromCenter === 0 || symmetryFactor > 0.9) {
            return x;
        }
        
        // For points to the right of center, possibly mirror to the left
        if (distFromCenter > 0 && Math.random() < symmetryFactor) {
            return centerX - distFromCenter;
        }
        
        // For points to the left of center, possibly mirror to the right
        if (distFromCenter < 0 && Math.random() < symmetryFactor) {
            return centerX + Math.abs(distFromCenter);
        }
        
        // Otherwise use the original position
        return x;
    }
    // Initialize the page when loaded
    document.addEventListener('DOMContentLoaded', () => {
        // Init accessibility features
        initializeAccessibility();
        
        // Initialize simulation with a short delay
        setTimeout(() => {
            initializeSimulation();
            statusUpdate.textContent = "Manila Clam Pattern Generator initialized. Adjust parameters and press 'Start New Growth Simulation' to begin.";
        }, 100);
    });

    // Add keyboard controls for better accessibility
    function initializeAccessibility() {
        // Keyboard controls for play/pause
        playPauseButton.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                togglePlayPause();
            }
        });
        
        // Make tab navigation work with the timeline slider
        timelineSlider.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                timelineSlider.value = Math.max(0, parseInt(timelineSlider.value) - 10);
                scrubTimeline();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                timelineSlider.value = Math.min(animationState.totalRows, parseInt(timelineSlider.value) + 10);
                scrubTimeline();
            }
        });
        
        // Make tab buttons keyboard accessible
        tabButtons.forEach(button => {
            button.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    button.click();
                }
            });
        });
        
        // Info region updates for screen readers
        generateButton.addEventListener('click', () => {
            setTimeout(() => {
                statusUpdate.textContent = "New shell pattern simulation created. Press play to start growth.";
            }, 100);
        });
        
        downloadButton.addEventListener('click', () => {
            setTimeout(() => {
                statusUpdate.textContent = "High resolution pattern downloaded successfully.";
            }, 100);
        });

        // Add aria labels to canvas size inputs
        canvasWidthInput.setAttribute('aria-label', 'Canvas width');
        canvasHeightInput.setAttribute('aria-label', 'Canvas height');
        canvasWidthUnit.setAttribute('aria-label', 'Width unit');
        canvasHeightUnit.setAttribute('aria-label', 'Height unit');
        canvasResolution.setAttribute('aria-label', 'Resolution in DPI');
    }
</script>
<style>
    /* Additional CSS for environmental history and growth info */
    .environment-history {
        width: 100%;
        max-width: 600px;
        margin-top: 15px;
        background-color: #f5f5f5;
        border-radius: 8px;
        padding: 15px;
    }

    .environment-history h3 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
    }

    .graph-container {
        position: relative;
        height: 100px;
        border-bottom: 1px solid #ccc;
        border-left: 1px solid #ccc;
        margin-top: 20px;
    }

    .graph-y-axis {
        position: absolute;
        left: -25px;
        top: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 10px;
    }

    .graph-line {
        position: absolute;
        width: 100%;
        height: 1px;
        background-color: rgba(0,0,0,0.1);
    }

    .data-line {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        pointer-events: none;
    }

    .data-point {
        position: absolute;
        width: 5px;
        height: 5px;
        border-radius: 50%;
        margin-left: -2.5px;
        margin-top: -2.5px;
    }

    .data-point.temperature {
        background-color: var(--ku-orange);
    }

    .data-point.salinity {
        background-color: var(--ku-blue);
    }

    .data-point.seasonal {
        background-color: var(--ku-green);
    }

    .data-point.microplastic {
        background-color: var(--ku-purple);
    }

    .data-point.acidification {
        background-color: var(--ku-tan);
    }

    .data-point.sediment {
        background-color: var(--pattern-growth);
    }

    .climate-trend {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top: 2px dashed rgba(255, 0, 0, 0.4);
        opacity: 0;
        transition: opacity 0.5s, transform 0.5s;
    }

    .graph-legend {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        margin-top: 15px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        margin-right: 10px;
        margin-bottom: 5px;
    }

    .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 3px;
        margin-right: 5px;
    }

    .legend-color.temperature {
        background-color: var(--ku-orange);
    }

    .legend-color.salinity {
        background-color: var(--ku-blue);
    }

    .legend-color.seasonal {
        background-color: var(--ku-green);
    }

    .legend-color.microplastic {
        background-color: var(--ku-purple);
    }

    .legend-color.acidification {
        background-color: var(--ku-tan);
    }

    .legend-color.sediment {
        background-color: var(--pattern-growth);
    }

    /* Growth information display */
    .growth-info {
        width: 100%;
        max-width: 600px;
        margin-top: 15px;
        background-color: var(--ku-light-blue);
        border-radius: 8px;
        padding: 15px;
    }

    .growth-info h3 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 16px;
        color: var(--ku-navy);
    }

    .growth-info p {
        margin: 5px 0;
        font-size: 14px;
    }

    .growth-event {
        padding: 8px;
        margin-top: 8px;
        background-color: rgba(255,255,255,0.7);
        border-radius: 4px;
        border-left: 4px solid var(--ku-green);
    }

    .growth-event.temperature {
        border-left-color: var(--ku-orange);
    }

    .growth-event.salinity {
        border-left-color: var(--ku-blue);
    }

    .growth-event.seasonal {
        border-left-color: var(--ku-green);
    }

    .growth-event.microplastic {
        border-left-color: var(--ku-purple);
    }

    .growth-event.acidification {
        border-left-color: var(--ku-tan);
    }

    .growth-event.sediment {
        border-left-color: var(--pattern-growth);
    }

    .growth-event .timestamp {
        font-weight: bold;
        font-size: 12px;
        color: #666;
    }

    /* Climate badge */
    .climate-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
        color: white;
        margin-left: 5px;
    }

    .climate-badge.pre-industrial {
        background-color: var(--ku-green);
    }

    .climate-badge.current {
        background-color: var(--ku-blue);
    }

    .climate-badge.near-future {
        background-color: var(--ku-orange);
    }

    .climate-badge.worst-case {
        background-color: #d9534f;
    }

    /* Pattern blend badges */
    .pattern-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 11px;
        color: white;
        margin-right: 4px;
    }

    .pattern-badge.cellular {
        background-color: var(--ku-orange);
    }

    .pattern-badge.wave {
        background-color: var(--ku-blue);
    }

    .pattern-badge.growth {
        background-color: var(--ku-green);
    }

    .pattern-badge.voronoi {
        background-color: var(--ku-purple);
    }

    .pattern-badge.radial {
        background-color: var(--ku-gold);
    }

    /* Tabs system */
    .tabs {
        width: 100%;
        max-width: 600px;
        margin-top: 15px;
    }

    .tab-buttons {
        display: flex;
        overflow-x: auto;
    }

    .tab-button {
        padding: 8px 15px;
        background-color: #e0e0e0;
        border: none;
        border-radius: 5px 5px 0 0;
        cursor: pointer;
        color: #333;
        font-weight: 500;
        margin-right: 2px;
        width: auto;
    }

    .tab-button.active {
        background-color: var(--ku-navy);
        color: white;
    }

    .tab-content {
        background-color: #f5f5f5;
        padding: 15px;
        border-radius: 0 5px 5px 5px;
    }

    .tab-panel {
        display: none;
    }

    .tab-panel.active {
        display: block;
    }

    .tab-panel h3 {
        margin-top: 0;
        color: var(--ku-navy);
    }

    .tab-panel ul {
        padding-left: 20px;
    }

    .tab-panel li {
        margin-bottom: 8px;
    }

    /* Responsive design improvements */
    @media (max-width: 768px) {
        .main-content {
            flex-direction: column;
        }

        .controls {
            min-width: 100%;
        }

        .canvas-container {
            min-width: 100%;
        }

        .blend-labels {
            flex-direction: column;
        }

        .blend-label {
            margin-bottom: 3px;
        }

        .tab-buttons {
            flex-wrap: wrap;
        }

        .tab-button {
            margin-bottom: 4px;
        }
    }

    @media (prefers-reduced-motion: reduce) {
        * {
            transition: none !important;
            animation: none !important;
        }
    }

    /* Improved focus styles for accessibility */
    button:focus-visible,
    input:focus-visible,
    select:focus-visible {
        outline: 3px solid var(--ku-yellow);
        outline-offset: 2px;
        position: relative;
        z-index: 1;
    }

    /* Screen reader only elements */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Screen reader announcements */
    .sr-status {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Print styles */
    @media print {
        .controls, .animation-controls, .action-buttons {
            display: none;
        }

        .canvas-container {
            width: 100%;
        }

        .tab-content {
            padding: 0;
            border: none;
        }
    }
    // Add event listener to watch for window resize and adjust canvas if needed
    window.addEventListener('resize', () => {
        // Ensure canvas and visualizations fit appropriately
        if (animationState.isPlaying) {
            // If animation is playing, make sure we maintain proper scaling
            updateEnvironmentGraph(animationState.currentRow);
        }
    });

    // Canvas download format optimization
    function optimizeCanvasForDownload() {
        const ctx = fullResCanvas.getContext('2d');
        
        // Apply image smoothing options based on resolution
        const dpi = parseInt(canvasResolution.value);
        
        if (dpi >= 200) {
            // For high resolution outputs, use higher quality settings
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        } else {
            // For lower resolution, prioritize pattern definition
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'medium';
        }
        
        // Return optimization status for accessibility announcements
        return dpi >= 200 ? "high resolution" : "standard resolution";
    }

    // Helper function to create a filename with metadata
    function createPatternFilename() {
        const scenario = climateScenarioSelect.value;
        const patternType = patternTypeSelect.value;
        const width = canvasWidthInput.value;
        const height = canvasHeightInput.value;
        const widthUnit = canvasWidthUnit.value;
        const heightUnit = canvasHeightUnit.value;
        const dpi = canvasResolution.value;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        
        return `manila-clam-${patternType}-${scenario}-${width}${widthUnit}x${height}${heightUnit}-${dpi}dpi-${timestamp}.png`;
    }

    // Event listener for simulation completion
    function onSimulationComplete() {
        // Generate a high-res pattern
        generateFullResolutionPattern();
        
        // Update status for screen readers
        const width = canvasWidthInput.value;
        const height = canvasHeightInput.value;
        const widthUnit = canvasWidthUnit.value;
        const heightUnit = canvasHeightUnit.value;
        const dpi = canvasResolution.value;
        
        // Announce completion
        statusUpdate.textContent = `Simulation complete. High resolution pattern (${width}${widthUnit} x ${height}${heightUnit} at ${dpi} DPI) is ready to download.`;
    }
</style>
</body>
</html>
